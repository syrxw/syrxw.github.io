{"pages":[{"title":"AboutMe","text":"","link":"/AboutMe/index.html"},{"title":"平时写的一些小东西","text":"404 Page Not Found","link":"/Instrument/index.html"},{"title":"关于我","text":"皇家布鲁斯特大学手扶拖拉机专业11届优秀毕业生，被大妈说是“学电脑的”。吃饱了撑得学前端.","link":"/about/index.html"},{"title":"平时写的一些小东西","text":"404 Page Not Found","link":"/Instrument/index副本.html"},{"title":"标签","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS让图片垂直居中的方式","text":"在网页设计过程中，有时候会希望图片垂直居中的情况。而且，需要垂直居中的图片的高度也不确定，这就会给页面的布局带来一定的挑战。下面总结了一下，曾经使用过的几种方法来使图片垂直居中。（持续更新中） #方法一 将外部容器的显示模式设置成display:table， img标签外部再嵌套一个span标签，并设置span的显示模式为display:table-cell，这样span内部的内容就相当于表格，可以很方便的使用vertical-align属性来对齐其中的内容了。 See the Pen epppNG by WangWenyu (@Jacobwang) on CodePen. #方法二 标准浏览器的情况还是和上面一样，不同的是针对IE6/IE7利用在img标签的前面插入一对空标签的办法。 See the Pen Lppppg by WangWenyu (@Jacobwang) on CodePen. #方法三 在img标签外包裹一个p标签，标准浏览器利用p标签的伪类属性:before来实现居中，另外，对于IE6/IE7使用了CSS表达式来实现兼容。 See the Pen ZbbbQJ by WangWenyu (@Jacobwang) on CodePen.","link":"/2015/09/10/CSS让图片垂直居中的方式/"},{"title":"PostCSS系列(三)-借助Gulp使用PostCSS","text":"在上一章中，我们介绍了如何在CodePen 和 Prepros中使用PostCSS，使用的效果确实很赞，但是，这并不能让你对PostCSS插件的使用有个完整的了解。 本篇教程中，我们将会借助Gulp这个工具来使用PostCSS，使PostCSS发挥更好的作用。关于Gulp的介绍和使用方法，在这里我就不做过多介绍了，之前我写了一个系列的文章，详细的介绍了Gulp的使用，点击这里查看 使用Gulp，就可以选择你自己需要的PostCSS插件，摆脱CodePen带来的插件局限性，真正的进入到PostCSS的生态圈里面 ##准备工作 使用Gulp之前，你必须确保下面这几个核心程序安装配置好了。 Node.js NPM Git 我在我之前的Gulp系列中也写到，一个完整的Gulp项目，需要gulpfile.js和package.json，而且还需要通过npm去安装Gulp。 ##开始上手Gulp PostCSS 在你的项目文件目录中，你需要建立两个文件夹，src和dest，src文件夹存放的是未被编译生成的样式文件，dest文件夹存放的是PostCSS编译转换之后的样式文件。 接下来，你需要在你的项目之中安装gulp-postcss这个插件，以便于PostCSS能够正常的运行起来。 在你的项目文件夹的根目录中打开终端命令器，（terminal/command ）。输入并运行命令： npm install --save-dev gulp-postcss 在经过这一系列安装之后，你的项目文件夹看起来会是这个样子的： 现在，打开你的gulpfile.js文件，输入如下代码： var gulp = require(&apos;gulp&apos;); var postcss = require(&apos;gulp-postcss&apos;); 这两句代码的意思就是引入gulp和gulp-postcss插件，这样我们就可以写gulp-postcss插件的配置命令了。接下来，我们来写一个读取CSS文件，再使用PostCSS使用的命令代码： gulp.task(&apos;css&apos;, function () { var processors = []; return gulp.src(&apos;./src/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dest&apos;)); }); 让我们来分解下上面这一段代码：首先，我们创建了一个名为css的Gulp任务，之后，任务中执行了一个回调函数。 接下来在这个回调方法中，我们创建了一个名为processors的空数组，之后PostCSS会用到这个数组，并向这个数组里面填充一些数据。 在创建一个数组之后，我们将要定义需要被PostCSS转换的CSS文件路径，指向src目录里面的任意CSS文件。 接着我们使用pipe()方法定义了两个管道，第一是调用postcss插件对CSS文件进行编译转换，第二个是使用Gulp进行压缩合并生成。 ##现在我们来试验下 在src文件夹中创建一个新的CSS文件，名为style.css，输入如下代码： .test { background: black; } 现在打开你之前的终端命令工具，输入如下命令并执行： gulp css 如果你配置正确的话，你在dest文件夹中就会看到一个生成之后的style.css文件。 打开这两个style.css文件，通过比对我们可以发现，这两个文件的代码并没有什么不同，这是因为我们还没有使用PostCSS插件的原因。 现在，我们引入几个PostCSS插件来试验下。 ##引入PostCSS插件 现在，我们将会使用Autoprefixer自动补全浏览器前缀,cssnext添加一些CSS新语法的支持,precss类似Sass内置方法的扩展 在终端中我们输入如下命令并执行： npm install autoprefixer --save-dev npm install cssnext --save-dev npm install precss --save-dev 提示：cssnext和precss安装可能需要一段时间，因为这两个集成了很多插件。 在安装好这几个插件之后，我们在gulpfilwe.js中声明这些插件： var autoprefixer = require(&apos;autoprefixer&apos;); var cssnext = require(&apos;cssnext&apos;); var precss = require(&apos;precss&apos;); 接下来，我们来更新下processors这个数组 var processors = [ autoprefixer, cssnext, precss ]; 我们将三个插件名添加到了processors这个数组中，这样PostCSS这个Gulp插件就会读取这个数组里面的内容，告知了PostCSS需要用到哪些插件。 清空之前你在style.css文件中的代码，添加如下代码 /* Testing autoprefixer */ .autoprefixer { display: flex; } /* Testing cssnext */ .cssnext { background: color(red alpha(-10%)); } /* Testing precss */ .precss { @if 3 &lt; 5 { background: green; } @else { background: blue; } } 运行gulp css命令，这是去查看dest文件夹中的文件，你会看到如下代码： /* Testing autoprefixer */ .autoprefixer { display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; } /* Testing cssnext */ .cssnext { background: rgba(255, 0, 0, 0.9); } /* Testing precss */ .precss { background: green } 在上面的代码中我们可以看到，浏览器兼容前缀已经被添加了进去，cssnext通过color方法输出了rgba()，@if @else也被执行了。 ##配置你的插件选项 提示：如果你想对PostCSS插件单独做一些配置，比如输出浏览器前缀，你只需要兼容一些主流浏览器，你可以这么编写代码实现配置： var processors = [ autoprefixer({browsers: [&apos;last 1 version&apos;]}), cssnext, precss ]; ##完成 说了这么多，终于完成了借助Gulp使用PostCSS了，这里我就不带着大家再次回顾了，跟着上面的流程走，相信你们一定也会轻松得学会PostCSS在Gulp中的使用。 本文参考链接：http://webdesign.tutsplus.com/tutorials/postcss-quickstart-guide-gulp-setup–cms-24543","link":"/2015/10/22/PostCSS系列(三)/"},{"title":"Flex 弹性布局拾缀","text":"综述flexbox是一个完整的模块而不是一个单独的属性，它包含了两个部分 父元素flex container，子元素flex items，这两个是属于一个包含关系 如图所示，flexbox有一个主轴main axis,还有一个侧轴cross axis main axis flex item排列的方向，当然这个方向是取决于flex-direction属性，并不是绝对的水平 main start | main end 主轴的开始位置与结束位置 main size 在主轴方向的宽度或高度就是项目的主轴长度 cross axis 与主轴垂直方向的轴叫做侧轴 cross start | cross end 侧轴的开始位置与结束位置 cross size 侧周方向的宽度和高度就是项目的测轴长度 Flexbox容器 display123.container { display: flex; /* or inline-flex */} 一旦设置容器为flex，容器内的CSS columns属性都会失效 flex-direction定义主轴方向 123.container { flex-direction: row | row-reverse | column | column-reverse;} row (default): 如果书写方式是ltr，那么flexbox从左向右排列；如果书写方式是rtl，那么Flex项目从右向左排列 row-reverse: 如果书写方式是ltr，那么flexbox从右向左排列；如果书写方式是rtl，那么Flex项目从左向右排列 column: 与row相同，方向变为上下 column-reverse: 与row相同，方向变为下上 flex-wrap定义是否是一行展示 123.container{ flex-wrap: nowrap | wrap | wrap-reverse;} 默认情况下，flex item都是在一行排列下展示的，可以根据需要来调整是否折行展示 nowrap: 所有的flex item都是在一行排列展示 wrap: 从上到下多行排列 wrap-reverse: 从下到上多行排列 flex-flowflex-direction 和 flex-wrap的集合体，默认值是row nowrap 1flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt; justify-content设置主轴方向上的对齐 123.container { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;} flex-start: 沿着起始点依次对齐排列 flex-end: 沿着结束点一次对齐排列 center: 居中对齐排列 space-between: 两端对齐，第一个元素紧贴起始点，最后一个元素紧贴结束点，剩余元素依次排开 space-around: 两端平均分布对齐 align-items设置侧轴方向的对齐 123.container { align-items: flex-start | flex-end | center | baseline | stretch;} flex-start: 侧轴起始点对齐 flex-end: 侧轴结束点对齐 center: 侧轴中心点对齐 baseline: 项目第一行文字对齐 stretch: 如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.container { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} flex-start: 侧轴起始点对齐 flex-end: 侧轴结束点对齐 center: 侧轴中心点对齐 space-between: 两端对齐，第一个元素紧贴起始点，最后一个元素紧贴结束点，剩余元素依次排开 space-around: 两端平均分布对齐 stretch: 轴线占满整个侧轴。 Flexbox元素order定义元素的顺序排列 123.item { order: &lt;integer&gt;; /* default is 0 */} 默认元素是按照文档流的顺序排列的，通过定义元素的order属性，可以改变元素的排列顺序 flex-grow定义一个元素的扩大比例 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 接收一个正整数，例如设置值为2,那么该元素就是其他元素的2倍占比空间 flex-shrink定义一个元素的缩小比例 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} flex-basis定义了在分配多余空间之前，元素占据的主轴空间（main size） .item { flex-basis: | auto; / default auto /} 例如设置了flex-basis为100px，那么该元素占据主轴空间为100px flexflex-grow, flex-shrink, flex-basis的合体 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} align-self单独设置元素的对齐方式 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;}","link":"/2018/06/24/Flexbox 弹性布局拾缀/"},{"title":"PostCSS系列(二)-快速上手PostCSS","text":"欢迎来到本系列教程的第二章，在上一章里，我带领大家了解了什么是PostCSS，以及PostCSS的优缺点和使用范围，这一章，我将会带大家快速上手PostCSS 本文翻译自：http://webdesign.tutsplus.com/tutorials/postcss-quickstart-guide-instant-setup-options–cms-24536 本篇教程中，我们将会使用到两个可以实时预览PostCSS效果的工具，所以你可以在很短的事件之内上手PostCSS，我们将会有这两个工具被使用到，它们分别是：CodePen和Prepros。 现在，让我们看看如何使用这两样工具吧 ##PostCSS在CodePen中的使用 如果你是第一次使用PostCSS，那么最快上手的方式就是在CodePen上使用。CodePen上已经集成了很多PostCSS插件，插件列表如下： cssnext postcss-simple-vars postcss-discard-comments postcss-custom-media postcss-media-minmax postcss-conditionals postcss-each postcss-for postcss-nested postcss-transform-shortcut 被预置的这些插件，已经对一些新颖的语法有了很好的支持，比如类似Sass中预置的方法，代码注释的分离，用简洁的语法写出可以被轻松转换的代码。现在，在CodePen上创建一个新的CodePen，在CSS旁边点击一下设置按钮，如图所示： 在CSS Preprocessor下拉选项里面选择PostCSS，当然你也可以在Vendor Prefixing这一项里够选上AUTOPREFIXER ，这样就集成了AUTOPREFIXER 这个插件了。 在你选择好之后，你可能会发现，在下拉菜单选项的右边有个Need an add-on，单击它，然后就会列出很多以@开头的列表选项，复制一些@列表选项，粘贴到CSS代码编写区域 ###在CodePen中是这样用的 现在我们来编写一个小例子，看看PostCSS是怎么使用的，这里我们用到了cssnext这个插件。在CSS代码面板区域，我们在顶部编写如下代码： @use cssnext; 这一行代码的意思就是告诉你，你可以使用有关cssnext的所有方法了，具体的方法描述你可以在这里看到，在这里，我们使用里面的variable和color方法来设置body的背景颜色 第一步，我们先来在:root部分定义一个颜色变量值，将如下代码粘贴到CSS代码区域面板中 :root { --body_bg_color: black; } 之后我们在添加如下代码： body { background: var(--body_bg_color); } 此时，在效果预览区域你应该能看到背景已经变成黑色的了，你可以点击View Compiled按钮来查看编译之后生成的代码 这时，你可能觉得黑色这个颜色有点太深了，你需要浅一点的颜色，你可以使用一种新颖的语法来改变这个颜色值，刚才的一段代码–body_bg_color声明了一个颜色值变量，我们可以这样修改，讲黑色减淡。 --body_bg_color: color(black lightness(20%)); 这个color方法lightens使黑色减淡了20%，现在你能看到背景色变淡了不少 只要是被支持的插件，你都可以这样使用 首先包含你要使用的@开头的插件规则，也就是引入这个插件 按照这个插件项目主页的文档说明使用这个插件 See the Pen PPEddw by WangWenyu (@Jacobwang) on CodePen. ##PostCSS在Prepros中的使用 Prepros并没有像CodePen一样有那么多的插件被支持，但是它可以无缝对接Autoprefixer 和 cssnext.你可以在这里下载Prepros 首先，你要把你的样式文件拖入到软件的主界面之中，点击文件名，右侧就能看到一些配置选项，这里你可以勾选 AutoPrefix CSS和Enable Cssnext来使用这两个插件。 ##回顾现在，让我们快速回顾下之前本章我们所说的： 使用CodePen 或者 Prepros 让你快速上手PostCSS CodePen提供了十个插件你可以使用 在CSS面板中，使用@开头的代码命令来引入你所需要使用的插件 Prepros提供了Autoprefixer 插件 and cssnext 包 你可以在Prepros中对任何CSS文件使用这两个插件","link":"/2015/10/21/PostCSS系列(二)/"},{"title":"Vue 项目中的nginx配置","text":"history模式下 配置rewrite规则123location / { try_files $uri $uri/ /index.html;} 配置接口的反向代理12345678910111213141516server { listen 80; server_name a.com; root /wwwroot/test; autoindex off; index index.html index.htm index.php; # 将a.com/api的所有请求反向代理到b.com location /open/api { proxy_pass http://b.com; } location ~ /\\.ht { deny all; }}","link":"/2018/06/10/Vue 项目中的nginx配置/"},{"title":"Webpack踩坑指南","text":"记录一下使用webpack上的一些坑 webpack-dev-server 导致的 invalid host header解决方法如下： 在 webpack-dev-server 的配置中添加 1disableHostCheck: true 新版本的webpack应该是在devServer字段下的配置 将host配置建议改成 1host: '0.0.0.0' 配置webpack的反向代理在开发调试模式中经常会遇到前端调试接口报跨域错误，可以这样配置 123456proxy: { '/open/api': { target: \"http://www.x.com\",//你本地前端服务配置的一个域名 changeOrigin: true, }}, 如果用的是vue-cli生成的项目，直接改config/index.js里面的配置即可","link":"/2018/06/10/Webpack踩坑指南/"},{"title":"axios 自动刷新 JWT Token","text":"axios 自动刷新 JWT Token本文转载自https://tiicle.com/items/141/automatically-refresh-jwt-axios-token 1、定义刷新 token 的路由1234$api = app('Dingo\\Api\\Routing\\Router');$api-&gt;version('v1', function($api){ $api-&gt;post('token', 'App\\Http\\Controllers\\AuthController@token');}); 2、刷新 token 的处理代码12345678910111213141516class AuthController extends Controller{ public function token() { $token = JWTAuth::getToken(); if (!$token) { throw new BadRequestHtttpException('Token not provided'); } try { $token = JWTAuth::refresh($token); } catch (TokenInvalidException $e) { throw new AccessDeniedHttpException('The token is invalid'); } return $this-&gt;response-&gt;withArray(['token' =&gt; $token]); }} 3、在 Axios 中处理 401 错误，自动刷新 Token1234567891011121314151617181920axios.interceptors.response.use(function(response) { return response}, function(error) { const originalRequest = error.config if (error.response.status === 401 &amp;&amp; !originalRequest._retry) { originalRequest._retry = true const token = window.localStorage.getItem('token') return axios.post('/v1/token', { token }) .then(({ data }) =&gt; { window.localStorage.setItem('token', data.token) axios.defaults.headers.common.Authorization = 'Bearer ' + data.token // retry request originalRequest.headers.Authorization = 'Bearer ' + data.token return axios(originalRequest) }) } return Promise.reject(error)})","link":"/2017/08/30/axios 自动刷新 JWT Token/"},{"title":"axios使用中的奇技淫巧","text":"response拦截器自动刷新token并重新发起请求业务场景：后台api接口返回code:-2 就代表着token不存在或者失效 1234567891011121314151617181920212223242526272829303132// respone拦截器service .interceptors .response .use(response =&gt; { const res = response.data if (response.data.code === -2) { const originalRequest = response.config//获取请求的config配置 const token = sessionStorage.getItem('token') if (token &amp;&amp; token !== '') { //token不存在的时候，会在router before中获取，这里只针对token失效的情况 return getToken().then(async(data) =&gt; { //重新获取token sessionStorage.setItem('token', data.data.token) originalRequest.params.token = data.data.token //由于Promise对象不支持返回值，这里选用了es新特性 async await 关键字 let res = await axios(originalRequest) return res.data }) } } if (res.code !== 0 &amp;&amp; res.code !== -2) { Toast({mes: res.msg, timeout: 1500, icon: 'error'}) return Promise.reject('error') } else { return response.data } }, error =&gt; { Toast({mes: error, timeout: 1500, icon: 'error'}) return Promise.reject(error) })","link":"/2018/06/10/axios使用中的奇技淫巧/"},{"title":"child_process.exec 来删除本地文件","text":"child_process.exec(command[, options][, callback])参数一表示 ：使用cmd执行的命令 在Windows环境下使用的命令是 rd/s/q 盘符:\\某个文件夹 （强制删除文件文件夹和文件夹内所有文件） del/f/s/q 盘符:\\文件名 （强制删除文件，文件名必须加文件后缀名）） 在linux环境下使用的命令是 rm -rf 代码示例 123456789//删除文件夹里面的git信息if(os.platform() === 'darwin'){ child = exec('rm -rf .git',{cwd: '/document'}, function(err, out) { console.log(out); err &amp;&amp; console.log(err); });}else if(os.platform() === 'win32'){ child = exec('rd/s/q .git',{cwd: \"D:/document\"});}","link":"/2018/05/14/child_process.exec 来删除本地文件/"},{"title":"PostCSS系列(四)-借助Grunt使用PostCSS","text":"在上一章中，我们向你介绍了在Gulp中使用PostCSS，这一章里，我们会向你介绍在Grunt中使用PostCSS。 Grunt和Gulp一样，也是一个前端集成解决方案工具，相对Gulp来说，Grunt显得较为笨重，这里我还是推荐大家使用Gulp，但是，Grunt的使用人数也不少，所以，我们还是要介绍一下PostCSS在Grunt中的使用。 使用Grunt，就可以选择你自己需要的PostCSS插件，摆脱CodePen带来的插件局限性，真正的进入到PostCSS的生态圈里面 ##准备工作 使用Grunt之前，你必须确保下面这几个核心程序安装配置好了。 Node.js NPM Git 一个完整的Grunt项目，需要gruntfile.js和package.json，而且还需要通过npm去安装Grunt。 ##开始上手Grunt PostCSS 在你的项目文件目录中，你需要建立两个文件夹，src和dest，src文件夹存放的是未被编译生成的样式文件，dest文件夹存放的是PostCSS编译转换之后的样式文件。 接下来，你需要在你的项目之中安装grunt-postcss这个插件，以便于PostCSS能够正常的运行起来。 在你的项目文件夹的根目录中打开终端命令器，（terminal/command ）。输入并运行命令： npm install grunt-postcss --save-dev 在经过这一系列安装之后，你的项目文件夹看起来会是这个样子的： 现在，打开你的gruntfile.js文件，输入如下代码： module.exports = function(grunt) { }; 接着，我们将会引入grunt-postcss插件 grunt.loadNpmTasks(&apos;grunt-postcss&apos;); 完成之后就会像这样： module.exports = function(grunt) { grunt.loadNpmTasks(&apos;grunt-postcss&apos;); }; 现在，我们已经成功的引入了grunt-postcss插件，也就是说，我们可以使用了PostCSS了。紧接着我们在之前的回调函数中输入如下代码，放在加载PostCSS代码之前： module.exports = function(grunt) { grunt.initConfig({ }); grunt.loadNpmTasks(&apos;grunt-postcss&apos;); }; 接着，我们添加一个PostCSS配置项： module.exports = function(grunt) { grunt.initConfig({ postcss: { } }); grunt.loadNpmTasks(&apos;grunt-postcss&apos;); }; 然后在配置对象里面再新增两个对象，分别是：options和dist module.exports = function(grunt) { grunt.initConfig({ postcss: { options: { }, dist: { } } }); grunt.loadNpmTasks(&apos;grunt-postcss&apos;); }; options是对PostCSS的一些配置 dist是对需要编译转换的文件路径的一些配置 ##现在我们来试验下 在src文件夹中创建一个新的CSS文件，名为style.css，输入如下代码： .test { background: black; } 我们在dist配置项里面输入如下代码： dist: { src: &apos;src/style.css&apos;, dest: &apos;dest/style.css&apos; } 接着在options里面配置： options: { processors: [ ] }, 接下来我们在终端里面输入命令执行： grunt postcss 然后你在终端中就会看到如下显示： Running &quot;postcss:dist&quot; (postcss) task &gt;&gt; 1 processed stylesheet created. 如果你配置正确的话，你在dest文件夹中就会看到一个生成之后的style.css文件。 打开这两个style.css文件，通过比对我们可以发现，这两个文件的代码并没有什么不同，这是因为我们还没有使用PostCSS插件的原因。 现在，我们引入几个PostCSS插件来试验下。 ##引入PostCSS插件 现在，我们将会使用Autoprefixer自动补全浏览器前缀,cssnext添加一些CSS新语法的支持,precss类似Sass内置方法的扩展 在终端中我们输入如下命令并执行： npm install autoprefixer --save-dev npm install cssnext --save-dev npm install precss --save-dev 提示：cssnext和precss安装可能需要一段时间，因为这两个集成了很多插件。 在安装好这几个插件之后，我们在gruntfile.js中声明这些插件： processors: [ require(&apos;autoprefixer&apos;)(), require(&apos;cssnext&apos;)(), require(&apos;precss&apos;)() ] 清空之前你在style.css文件中的代码，添加如下代码 /* Testing autoprefixer */ .autoprefixer { display: flex; } /* Testing cssnext */ .cssnext { background: color(red alpha(-10%)); } /* Testing precss */ .precss { @if 3 &lt; 5 { background: green; } @else { background: blue; } } 运行grunt postcss命令，这是去查看dest文件夹中的文件，你会看到如下代码： /* Testing autoprefixer */ .autoprefixer { display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; } /* Testing cssnext */ .cssnext { background: rgba(255, 0, 0, 0.9); } /* Testing precss */ .precss { background: green } 在上面的代码中我们可以看到，浏览器兼容前缀已经被添加了进去，cssnext通过color方法输出了rgba()，@if @else也被执行了。 ##配置你的插件选项 提示：如果你想对PostCSS插件单独做一些配置，比如输出浏览器前缀，你只需要兼容一些主流浏览器，你可以这么编写代码实现配置： processors: [ require(&apos;autoprefixer&apos;)({browsers: [&apos;last 1 version&apos;]}), require(&apos;cssnext&apos;)(), require(&apos;precss&apos;)() ] ##完成 说了这么多，终于完成了借助Grunt使用PostCSS了，这里我就不带着大家再次回顾了，跟着上面的流程走，相信你们一定也会轻松得学会PostCSS在Grunt中的使用。 本文参考链接：http://webdesign.tutsplus.com/tutorials/postcss-quickstart-guide-grunt-setup–cms-24545","link":"/2015/10/22/PostCSS系列(四)/"},{"title":"git commit emoji 使用指南","text":"git commit emoji 使用指南git commit emoji 使用指南执行 git commit 时使用 emoji 为本次提交打上一个 “标签”, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。 截取的 gitmoji 快照: commit 格式git commit 时，提交信息遵循以下格式： 12345:emoji1: :emoji2: 主题提交信息主体Ref &lt;###&gt; 初次提交示例： 1git commit -m \":tada: Initialize Repo\" emoji 指南 emoji emoji 代码 commit 说明 :art: (调色板) :art: 改进代码结构/代码格式 :zap: (闪电):racehorse: (赛马) :zap::racehorse: 提升性能 :fire: (火焰) :fire: 移除代码或文件 :bug: (bug) :bug: 修复 bug :ambulance: (急救车) :ambulance: 重要补丁 :sparkles: (火花) :sparkles: 引入新功能 :memo: (备忘录) :memo: 撰写文档 :rocket: (火箭) :rocket: 部署功能 :lipstick: (口红) :lipstick: 更新 UI 和样式文件 :tada: (庆祝) :tada: 初次提交 :white_check_mark: (白色复选框) :white_check_mark: 增加测试 :lock: (锁) :lock: 修复安全问题 :apple: (苹果) :apple: 修复 macOS 下的问题 :penguin: (企鹅) :penguin: 修复 Linux 下的问题 :checkered_flag: (旗帜) :checked_flag: 修复 Windows 下的问题 :bookmark: (书签) :bookmark: 发行/版本标签 :rotating_light: (警车灯) :rotating_light: 移除 linter 警告 :construction: (施工) :construction: 工作进行中 :green_heart: (绿心) :green_heart: 修复 CI 构建问题 :arrow_down: (下降箭头) :arrow_down: 降级依赖 :arrow_up: (上升箭头) :arrow_up: 升级依赖 :construction_worker: (工人) :construction_worker: 添加 CI 构建系统 :chart_with_upwards_trend: (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 :hammer: (锤子) :hammer: 重大重构 :heavy_minus_sign: (减号) :heavy_minus_sign: 减少一个依赖 :whale: (鲸鱼) :whale: Docker 相关工作 :heavy_plus_sign: (加号) :heavy_plus_sign: 增加一个依赖 :wrench: (扳手) :wrench: 修改配置文件 :globe_with_meridians: (地球) :globe_with_meridians: 国际化与本地化 :pencil2: (铅笔) :pencil2: 修复 typo 如何在命令行中显示 emoji默认情况下，在命令行中并不会显示出 emoji, 仅显示 emoji 代码。不过可以使用 emojify 使得在命令行也可显示 emoji, 它是一个 shell 脚本，安装与使用都很简单，在 这里 查看如何安装与使用。 参考 gitmoji An emoji guide for your commit messages styleguide-git-commit-message atom git commit messages guide emoji-cheat-sheet 程序员提交代码的 emoji 指南——原来表情文字不能乱用","link":"/2017/09/20/git commit emoji 使用指南/"},{"title":"Mark of the Web 关于WEB标志的那些事","text":"最近在看《HTML5秘籍》这本书，书中在第一章介绍到了Mark of the Web这个名词，中文翻译过来也就是WEB标志。那到底这个名词具体有什么作用呢？ Mark of the Web (MOTW)是IE浏览器中，安全性中的一个特性，在你使用ie浏览器浏览网页的时候，经常会遇到一些安全性阻止警告。这些警告非常烦人，但IE浏览器出于安全性考虑，会将一些脚本阻止。这时加上MOTW就可以在IE浏览器中正常测试你的网页。 #什么是WEB标志？ MOTW是添加在网页中的HTML注释， 当用户在本地打开网页时, IE浏览器会根据这行注释，取消出于安全考虑的需要阻止的文件. MOTW注释是这样写的： &lt;!-- saved from url=(0023)http://www.contoso.com/ --&gt; 为了能有效使用MOTW，需要遵循一些规则： 1.必须以如下代码开头： &lt;!-- saved from url= 2.必须以如下代码结尾 --&gt; 3.url=(####)这里的####填写四个数字，是你在后面填写的字符长度。IE浏览器会根据这个数字进行读取 #一些不同的使用 如果你的站点是在线上，并且有解析好的域名，那么你要这样使用： &lt;!-- saved from url=(0014)about:internet --&gt; 如果你的站点是在本地，那么你要这样使用： &lt;!-- saved from url=(0016)http://localhost --&gt; #一个完整的示例 &lt;!doctype html&gt; &lt;!-- saved from url=(0023)http://www.contoso.com/ --&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;A Mark of the Web Example.&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello, World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; #有哪些弊端 关于弊端这块，我还没有遇到。如果大家有遇到，请大家在底下的评论区域反馈。 #参考资料 MSDN资料链接","link":"/2015/09/09/什么是WEB标志/"},{"title":"一步步带你折腾出一个Hexo博客主题(一)","text":"之前是想先做个Hexo使用教程的，但突然发现那是个重复轮子活，所以就不再耗费时间去写那个了，简书上的那篇文章说的很详细。 写这篇的原因是我发现关于Hexo主题制作的教程还是比较少的。所以，就写一篇这个来记录一下我的这个小站的主题是怎么出来的。 看到Hexo程序的时候，我就喜欢上了这个小巧的博客程序，看到官方默认的几套主题，我不是很喜欢，所以立马就决定自己写一套主题自己用。（虽然很粗糙，但还是有点成绩感的，哈哈） 主题的设计思路 首先，自己不是专业的设计师，所以，设计出来的东西难免会有些粗糙。整个主题就是以简洁为主，没有什么其他复杂的绚丽的元素，黑白灰三个色调贯穿。使用的软件是Mac上的Sketch，堪称网页设计神器啊！主题是基于Light这个基本主题修改而来 主题文件的结构分析 ###基本结构 Hexo的主题全部存放于Hexo主程序文件夹根目录的themes文件夹中，这里以本站主题Hexo_Theme_Concise为例。 languages文件夹里面的内容对应的是全球化的配置 layout文件夹里面对应的就是主题的模板文件 source文件夹里面对应的就是css，js之类的文件 _config.yml文件是主题的配置文件 剩下来的两个文件分别对应的是协议和github上带有的描述文件 ###详细结构 主题的模板是用ejs编写而成，有关ejs的详细文档和教程，请点击官网查看详情，可能会被墙掉，大家做好翻墙的准备，在这里我推荐大家用红杏翻墙的这个软件红杏 1.首先整个主题的HTML结构是在layout.ejs这个文件里 12345678910111213141516171819202122232425262728293031 &lt;%- partial(&apos;_partial/head&apos;) %&gt;&lt;body&gt; &lt;!-- 顶部导航--&gt; &lt;header class=&quot;header&quot;&gt; &lt;%- partial(&apos;_partial/header&apos;) %&gt; &lt;/header&gt; &lt;!-- end build--&gt; &lt;!--内容区域--&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;wrap alignleft&quot;&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;aside class=&quot;sidebar alignright&quot;&gt; &lt;%- partial(&apos;_partial/sidebar&apos;) %&gt; &lt;/aside&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- end build--&gt; &lt;!--底部区域--&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;%- partial(&apos;_partial/footer&apos;) %&gt; &lt;/footer&gt; &lt;!-- end build--&gt; &lt;%- partial(&apos;_partial/after_footer&apos;) %&gt;&lt;/body&gt;&lt;/html&gt; &lt;%- body %&gt;这段代码所对应的区域是页面的主题内容部分 你会发现，有多处这样的代码&lt;%- partial('_partial/header') %&gt;，这里的意思就是将不同的模板文件引入进来，模板的位置位于_partial文件夹中。 2.archive.ejs是归档页面，category.ejs是分类页面，post.ejs是文章内容页面，tag.ejs是文章标签页面。 由于这几个页面的代码相同，所以以archive这个页面做代码分析 1&lt;%- partial(&apos;_partial/archive&apos;, {pagination: config.archive}) %&gt; 其中，前半部分引用的与layout页面引用相同，后面{}部分属于ejs语法，将一些全局的配置当做ejs中的变量传入到ejs的模板中，nodejs对应的npm包就会编译这些。","link":"/2015/05/04/一步步带你折腾出一个Hexo博客主题(一)副本/"},{"title":"在Wordpress主题中使用ngBindHtml显示文章内容","text":"第二章：在Wordpress主题中使用ngBindHtml显示文章内容 本文翻译:AngularJS WordPress Theme: Display Post Content with ngBindHtml 在我上一篇文章中的最后一张截图中 你一定会对文章内容显示带有HTML标签感到诧异。就像这样的： 其实这并不是一个bug，我是有意的将ngBindHTML directive单独的作为一块来说明的 (jacob:后来我查阅了不少资料，作者在这并没有说明为什么会出现HTML标签。这是AngularJS的内部机制，为了防止类似xss的攻击，AngularJS将HTML代码并没有做转义解析。) ngBindHTML是AngularJS的一个指令，作用是将HTML代码绑定在view上，现在，请更新你的content.html 之后，你会发现，之前的post消失了，这时，打开你的console，你会看到一些错误提示 出现这种错误的原因，是因为AngularJS告诉我们，文章内容的这段HTML可能是不安全的，很庆幸的AngularJS帮我们拦截下来了，这时，我们需要一个叫做ngSanitize的module来净化我们的HTML。 ###当使用ngBindHtml时，请确定你的$sanitize是可以使用的。 当你将一段带有元素标签的HTML代码绑定在页面上时，使用ngSanitize中的ngBindHtml是最佳实践。让我们一起更新项目文件吧。 ###1.下载ngSanitize模块 使用bower install angular-sanitize命令下载这些脚本文件，或者你也可以从GitHub repo这里获取到最新的代码。 ###2.引入脚本文件 15-19行，注册脚本文件 24行，添加angularjs-sanitize依赖项 ###3.更新你的脚本文件 1行，添加ngSanitize模块依赖项 正常情况下，我们看到的页面应该是这样的 ###是否还会有其他的安全性很高的转换HTML方法 当我说使用ngSanitize模块是处理AngularJS绑定HTML的最佳实践，你一定很好奇，还有没有其他方法可以实现呢？答案是肯定的，$sce 服务中Documentation有个trustAsHTML可以使用。 当你只使用trustAsHTML而不将ngSanitize引入的时候，即使你1000%确信你的结果是绝对安全的。换句话来说，你不应该这样做。 ###1.在scripts.js中创建一个自定义过滤器 1行，为了我们能正常使用trustAsHTML，我移除了ngSanitize。但是最好的方法是，当你需要绑定HTML时候，你应该总是在app中添加ngSanitize模块来使用ng-bind-html 5-9行，自定义的过滤器，我们创建了一个名为toTrusted的过滤器，目的是为了文本在显示的时候，是被过滤器转换过的，而不是直接被输出了出来。 ###2.在文章内容中使用过滤器 2行，post.content | toTrusted，竖线左边，是输出前的文本，通过右边的过滤器的使用，渲染在页面上的数据是被过滤器过滤之后的数据。 你得到的结果应该跟刚才一样才对。 在用户输入一些数据的时候，数据的安全性是我们最先要考虑的。防止被xss攻击。 在AngularJS中，$sce服务对建立一个客户端app是一个很好的开始，这本ng-book 上对这些做了些说明，推荐大家看看。 请享受这次阅读，这篇教程一定会对你有所帮助。","link":"/2015/06/07/使用angularjs构建wordpress主题(二)/"},{"title":"使用pm2与git仓库部署Node应用","text":"背景近几日将公司项目开了一个新坑，使用Nodejs进行服务端渲染，为公司团队前后端分离往前推进了一大步，本文就介绍了如何将开发好的Node程序在服务器上完成高逼格自动化部署 技术架构 开发环境：MacOS 10.13 程序：Koa+requirejs 服务器：公司内网服务器 Centos6.8 代码托管：公司内部gitlab 程序端口：3000端口 使用pm2进行托管部署 服务器环境初始化接下来以公司服务器系统Centos6.8为例进行说明：服务器上需要安装以下程序和依赖 Nodejs (项目中运用了大量的ES6，ES7语法，所以我们安装是7.9以上版本) NPM PM2 npm install pm2 -g Git yum install git 连接服务器作为一名极客，我推荐使用ssh命令行连接服务器ssh -p 2222 root@212.22.2.22(放弃吧，上面的地址是假的，你们连不进去的) 安装nodejs这里我推荐使用nvm进行服务器上node版本管理使用命令wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 安装完成之后将nvm写进系统环境变量中，分别执行export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 使用如下命令安装7.9.0版本的nodejsnvm install 7.9.0 安装完成之后会自动切换成7.9.0版本，如果没有切换，可以使用nvm use 7.9.0具体使用方法请看文末参考文章。 tips:安装完nvm之后，可能会发现nvm没有生效，这时退出服务器连接再进入就行了 安装pm2由于国内网络不可抗力因素，通常我们安装npm包都很慢，这里推荐切换成淘宝源来安装此处安利神器nrm 这是一个管理你本地npm源的工具，超级好用 首先安装nrmnpm install nrm --registry=https://registry.npm.taobao.org 安装成功后，使用命令nrm ls 看到如下界面： 使用nrm use taobao 选择淘宝源，然后你就可以放肆地下载各种npm包了。 输入npm install pm2 -g 安装pm2 服务器初始环境就暂时告一段落，接下来我们回到本地的配置上来。 安装Git使用yum install git 进行git的安装这里推荐阿里云的镜像 配置Git私钥使用ssh-keygen在~/.ssh下生成密钥id_rsa,将生成的id_rsa.pub文件复制到git仓库的ssh-key配置页面中 本地程序配置本地同样要有nodejs，npm，pm2，安装方式和服务器上的一样，这里就不过多赘述。 本文是基于程序代码托管在git上，换句话说就是使用git进行版本控制的，所以本文所述内容不适合svn用户。 使用pm2的ecosystem终端打开本地程序根目录地址，输入pm2 ecosystem,会在你本地生成一个ecosystem.config.js，参照官方文档，我们的配置如下，仅供参考： 12345678910111213141516171819202122232425262728293031323334353637383940module.exports = { apps: [ { name: 'app', script: './bin/www', env: { COMMON_VARIABLE: 'true' }, env_production: { NODE_ENV: 'production' } }, ], deploy: { production: { user: 'root',//服务器用户名 host: '22.22.222.22',//服务器地址 port: '4922',//服务器连接端口号，默认不写为22 ref: 'origin/master',//发布的分支版本 repo: 'git@xxx.top:front-end/scapp.git',//仓库地址 path: '/home/wwwroot/scapp',//发布的服务器文件位置 'post-deploy': 'npm install --production &amp;&amp; pm2 reload ecosystem.config.js --env production',//部署后需要执行的命令 env: { NODE_ENV: 'production' } }, dev: { user: 'root', host: '22.22.222.22', port: '4922', ref: 'origin/master', repo: 'git@xxx.top:front-end/scapp.git', path: '/home/wwwroot/scapp', 'post-deploy': 'npm install --production &amp;&amp; pm2 reload ecosystem.config.js --env dev', env: { NODE_ENV: 'dev' } } }}; 因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：scp -P 4922 ~/.ssh/id_rsa.pub root@22.222.22.22:/root/.ssh/authorized_keys 这一步很关键，测试成功的方式就是你通过ssh连接服务器，不用再输入密码了，这里面有不少坑，具体等待各位自己踩坑。 回到本地应用目录，执行命令：pm2 deploy ecosystem.json production setup 成功会提示success，如果失败，提示Host key verification failed. 就是没有将你的git仓库加进known_hosts中，在服务器中，注意，在服务器中执行命令：ssh-keyscan -t rsa 你的git仓库地址 &gt;&gt; ~/.ssh/known_hosts 加入成功之后，回到本地继续执行：pm2 deploy ecosystem.json production setup 这里的production对应的就是刚才的配置文件中的deploy字段下面的属性。配置文件中我写了production和dev，这里我们使用了production进行发布示例。 不出意外，成功之后提示 ○ setup complete–&gt; Success 项目部署代码提交这一步很重要，发布之前必须保证git的代码与你本地的保持一致。 代码发布在本地程序根目录下输入：pm2 deploy ecosystem.json production 等待服务器上npm的安装，代码的更新，成功之后看到的应该是如下： 至此，我们的程序发布成功。 在服务器上输入命令pm2 list查看程序运行的状况 参考文章 使用 nvm 管理不同版本的 node 与 npm npm换源 通过Github与PM2部署Node应用 服务器上的 Git - 生成 SSH 公钥 SSH Passwordless Login Using SSH Keygen in 5 Easy Steps","link":"/2017/10/26/使用pm2与git仓库部署Node应用/"},{"title":"写在我的2015","text":"##写在我的2015 ###一、2015真的快要结束了吗 没错，转瞬之间2015年已经进入尾声。 今年已经是我在社会上工作的第二年，两年的社会历练，让我明白了很多道理，但。。 从月初就说这个月一定要完成这篇属于我的2015记录，然而又是因为所谓的种种原因，拖到了现在才写。 2014年是慌慌张张，匆匆忙忙的一年，对于2014年，我已然没有什么特别深刻的记忆。如果给2014年一个结束词，那就应该是依旧。 但2015年，我赋予这一年的结束词是改变。 今年我发生了太多的改变，身形上的变化，又回到了校园上课，换了一份工作，技能又进一步的提升，还有太多太多的改变。 ###二、今年又get到什么新技能了吗 自己是混前端圈的，迷途中的前端小白一只。对于自己的职位，前端工程师，说白了就是做网页的，大家只要知道我是个做网页的就行，我可不是修电脑的。 今年陆陆续续接触到了很多新技能，其实就是很多新的前端框架，比如Angularjs，Nodejs之类的。也阅读了很多技术书籍，有好有坏。 1-2月之间，在鼓捣移动端的开发，去年年底发现自己的原生js去写DOM操作能力异常薄弱，中了jQuery的毒。所以索性在移动端的研究中，使用了原生js去做了很多操作。 这期间看了一本书《HTML5触摸界面设计与开发》这本书入门移动端web开发入门非常有帮助，书中介绍了很多关于移动端性能优化的提升，移动端开发所涉及到的一系列的事件API，一些常用手势的编写，单点触控和多点触控，PJAX的应用制作的一些引申，但是这本书的示例代码会有一定的问题，比如变量名的引用错误等等。这本书让我在进入移动端开发领域有很大的启发。 3-5月之间一直在鼓捣mvvm这类的框架，趁乱有机会做了两个项目投产。 这几个月中阅读的技术书籍就比较多，首先关于Angularjs的书读了三本，比较推荐的是《精通AngularJS》这本。这本书对Angularjs讲解的比较深刻。其实Angular2.0的版本出来我还是比较震惊的，完全颠覆了自己1.0的版本。引入了typescript这门神奇的语言，TS在之前用白鹭引擎做游戏开发的时候学过一次，确实弥补了很多JavaScript语言本身的不足，随着ES6，ES7的出现，TS还能否占据市场我们不得而知。 其次就是对Sass和Less的再一次深入学习，四月份的时候使用Stylus写了个博客主题，对这类CSS的预编译，后编译多多少少有了一定的认知。非常系统的阅读了Compass的构建。 由于自身的工作原因，我并没有在前端MVVM这一块有深入的学习很研究，不过总算入了个门。 近两个月，Vue一直出现在前端圈之中，因为1.0版本终于出来了，我在四月份的时候使用了Vue 0.11做了一次项目投产，当时这个View层的渲染框架还只是View层，没有路由，没有强大的与服务器端通讯。 5-7月之间属于比较混乱的两个月，发生了太多的变数，暂且不提。 8月初的时候，去上海参加了一次中国第二届CSS开发者大会，这个会议上，我见识到了BAT等其他大公司很多新颖的前端技术，同时，也学到了字体设计的文化。具体还是看知乎问答吧。 8月开始，接触到了前端框架这一块的编写，自己本身在页面构建上基础就不是很扎实，这也导致了我在工作中经常会出现很多严重的问题。这个部分的总结就放到明年吧。 关于技术这一块，我不做太多的总结，总结下去的话我就要分章节来写了。。过于繁琐。 最后吐槽下前端圈子来结束这个技术话题总结。太沉重了，开篇就上技术文。 对于目前的前端圈子，浮躁现象四期，每隔18个月，前端技术就会有新一轮的变化，比如进入下半年之后，ES6的发布，ES7的出现，React框架的火热，多多少少给前端圈带来了很多活力。 ###三、我又回到了校园生活 打从去年毕业出来工作，就特别怀念在校园的时光，工作越久，对校园里面的学生越发的羡慕。于是乎在2014年底，我报考了成人高考函授教育，顺利的进入了合工大继续我的本科生涯。 四月份迎来了开学的日子，由于是函授教育，所以不可能每天都在学校待着，这一次在学校上课的周期是两个星期。 开学前的某一天，我突然就收到了一条短信，竟然是班长发来的，说的是一些开学情况和班级群号。我第一反应就是，这丫的是骗子吧，我们班长就这么凭空冒出来了？我抱着半信半疑的态度，勇敢的加入了群里。没错，那真的是班长，至于班长是怎么选举出来的，我至今还不清楚。 凭借着多年在网络上吹水的经验，很快我就加入到了班级群的吹水之中，在一段时间的聊天之后，我们发现了一个问题，就是有一哥们的群等级特别的高，平时不怎么发言，分还这么高，这到底是用了什么样的黑魔法。（开学见面之后，这哥们已将秘诀传授于我们） 贝贝说，开学那天是我们会见网友的日子。在网络上聊得这么火热的大家，在现实中会面会不会是见光死呢？ 我们印证了这句话的真假，一把辛酸泪。 两周的工大课程让我认识了几位小伙伴，我们组成了葫芦娃队伍，作为大娃的老王，也就是我，贝贝是二娃，神棍斌是三娃，饭饭是四娃，浩浩是五娃，bug是六娃，桐桐是七娃，我们组成了葫芦娃班委会，维护着班级的秩序。（说得好官方，我自己都不信了）。虽然是短短几周时间，但我们几个在班级里，校园里发生的事情却能说上一天一夜。（我觉得我需要开一个番外篇来说一下我们的葫芦娃故事。） ###四、换了份工作 恩，换了一份工作，依旧是切图狗。 ###五、你还要继续胖下去吗？ 不要，坚决不要！ 胖这个字眼已经伴随我很多年了，相信很多人跟我一样，都为肥胖而苦恼着。（这句很像广告词，估计是自己广告看多了的缘故）。下了多次决心想去减肥什么的，呵呵，不用想都知道根本没有付出实践。 今年最大的改变就是身形上的变化，从14年10月下决心不再让自己的体重进行无节制的增长开始，到现在断断续续减掉了40斤左右。这个数字对比那些三个月狂瘦60斤，一年狂减200斤的，根本不值得一提。但是，对我来说，影响甚大。 我应该可以说我减肥成功了。 还是说下有什么方法可以瘦下去呢？ 第一种方法就是每天默念我很瘦2000遍，这是一种古老的巫术，起源于东方耳辞源，一般这种方法存在着一定的洗脑与反洗脑的过程，但成功之后效果显著。不过我没有用过，感兴趣的朋友可以去试试看。 第二种方法就是我所使用的方法点击此处进行回复即可查看完整方法 ###六、2016想做那些事？1.完成IOS开发的学习，报了个班，1-4月三个月的培训即将开始。争取拿到优秀学员。 2.完成今年没有完成的乐器学习。 3.通过学位英语考试。并且上课不挂科。 4.至少去祖国两个地方游玩。 5.暂时只想到这么多了。","link":"/2015/12/30/写在我的2015/"},{"title":"利用nodejs在线编译打包心得分享","text":"最近在开发一个自定义主题生成工具，需求场景是前台通过修改预置的sass变量，在线生成新的css文件提供下载或者提供内网cdn地址，还可以预览调整的样式。于是花了一两天大致实现了整个流程，其中还踩了几个坑（没有大量阅读文档的后果）现在把实现思路记录并分享出来，希望能给大家一点点参考。 用到的技术点Nodejs的Koa框架，Redis缓存，node-sass基于libsass c++的node实现 以编译SCSS文件为例这里我先画了个流程图，帮助理解 我把整个业务分成了三个功能来做： 生成编译、并压缩之后的文件 生成预览样式，不生成文件，不进行压缩，清理 读取预览样式文件，浏览器请求某个地址，返回类型为text/css样式文件流 首先程序启动，第一步要做的事就是把要编译的scss入口文件内容写入redis 12345678app.use(async(ctx, next) =&gt; { const styles = await redis.getKey(\"origin_scss_data\") if(!styles){ const fileData = await fs.readFile(`${process.cwd()}/src/sass/noa.scss`, 'utf8') await redis.setKey(\"origin_scss_data\",fileData) } await next();}) 接着前台页面编写输入框，并设置好对应的钩子 1&lt;input type=\"text\" id=\"blue\" placeholder=\"请输入\" value=\"#0090ff\"&gt; 这里将id作为钩子，也可以使用data api作为钩子 页面放置生成、预览按钮，点击之后通过遍历页面输入框，获取value，生成scss变量内容 123456789function generateColorMap(){ var content = '' $('.form-block input[type=text]').each(function(){ content += '$'+ $(this).attr('id') + ':' + $(this).val()+ ';' }) return content;} 生成点击生成按钮，通过ajax调用后台的生成接口，这里大致附上编译代码 123456789101112131415161718192021222324252627282930//生成文件名const fileName = ctx.request.body.name;const tempFile = path.join(`/css/${fileName}.css`)const styleResult = await this._compileStyles(fileName, ctx.request.body.content)//结果buffer流再丢到postcss中去await postcss([autoprefixer, comments]) .process(styleResult.css, {from: tempFile, to: tempFile}) .then(async result =&gt; { const output = new CleanCSS().minify(result.css); await fs.outputFile(tempFile, output.styles) }) static async _compileStyles(name, content) { //获取原始入口文件 const scssData = await redis.getKey(\"origin_scss_data\") //拼合样式 const newContent = `${content} ${scssData}` //通过node-sass进行编译 return sass.renderSync({ data: newContent, includePaths: [`${process.cwd()}/src/sass/`], });} 大致流程就是获取前台传入的文件名和scss变量内容，在后台redis中取出原始文件内容，拼合成新的scss文件内容，丢入node-sass中编译，然后通过postcss进行处理，再在本地生成一个css文件 预览生成预览的样式和之前生成样式文件的思路差不多，差别就是文件名是随机生成的，不使用postcss，最后将内容存入redis中，不生成本地文件，当然，这个随机文件名在编译成功后会传回给前台，方便进入下一步跳转。 预览需要在后台写一个读取文件接口，这里简单写了下 12345const name = ctx.query.nameconst fileData = await redis.getKey(`${name}`)ctx.type = 'text/css; charset=utf-8'ctx.body = fileData 有了读取样式文件的接口，这时我们就要在预览页面带上这个name参数，页面通过获取name参数，请求接口，即可读取到预览暂存的样式文件 1http://localhost:3009/loadStyles?name=ignuqzhd6s 总结大致思路看起来很简单，但是值得注意的点有很多： 初始将文件存入redis，为了减少对磁盘io的次数 不到最后一步，能不io文件就不去io文件 写之前泡在npm社区好好读文档 gulp打包很慢，慎用 cssnano压缩样式很慢，还有bug，慎用","link":"/2018/08/27/利用nodejs在线编译打包心得分享/"},{"title":"前端集成解决方案实践（三）使用神器livereload进行页面的自动刷新","text":"你还在为每次写完样式或者脚本要刷新页面而烦恼吗？我想答案是肯定的。 #引入gulp-livereload livereload这个想必大家之前也有听说过，我在grunt上就用过这个，但是grunt的配置文件太难写，我就一直没有用下去。换到了gulp上，gulp上也有相同的插件gulp-livereload。打开gulpfile.js这个文件，找到这样一句代码： var livereload = require(&apos;gulp-livereload&apos;); 引入livereload模块 #如何使用？ 在你编写的任务里面最后加上这样的一个pipe：.pipe(livereload());就像这样： //compass gulp.task(&apos;compass&apos;, function() { gulp.src(&apos;./src/sass/main.scss&apos;) .pipe(compass({ config_file: &apos;./config.rb&apos;, css: &apos;dist/css&apos;, sass: &apos;src/sass&apos;, require: [&apos;susy&apos;] })) .pipe(gulp.dest(&apos;./dist/css&apos;)) .pipe(livereload()); }); 接下来在default任务中添加监听方法 livereload.listen(); 这样，我们在gulp中的对livereload配置已经完成。接下来到了至关重要的一步 #如何让页面自动刷新？ 作为前端开发者，浏览器肯定首选chrome，这时你必须要安装个扩展程序。当然你是要翻墙的，这里推荐红杏翻墙插件（广告） 点击这里安装并注册红杏，自觉充值vip 打开chrome之后，这里献上livereload插件地址 安装完成后，通过本地搭建的服务器，打开你的页面，在浏览器的右上角就能看到这个小图标 点击一下，图标状态变成了实心的。这时候也就开启了livereload对页面的监听。这是你每次编辑main.scss这个文件的时候，保存编译成功之后，浏览器就会跟着自动刷新，再也不用进行那烦人的手动刷新了。 #总结 总结一下，这三篇文章就是对前端集成解决方案的一次实践分享，内容我精简了很多，因为实在没时间了。。如果大家有任何疑问的话，就在底下评论，我看到了会一一回复的。时间仓促，请各位包涵。","link":"/2015/08/14/前端集成解决方案实践（三）/"},{"title":"前端集成解决方案实践（二）使用gulp自动编译sass","text":"上一篇介绍了gulp的基本使用，可以让gulp正常的运行起来了。好工具光知道使用还不行，我们还要知道在项目里如何优雅的使用gulp（知乎风又来了。。再刷知乎就剁手) 在这两个月里我所做的项目中，我都使用到了使用sass去编写样式文件，搭配Gulp去跑起了整个项目，大大减少了我的工作量，缩短了工作时间。那么，如何才能将sass和gulp联系在一起使用呢？ #配置sass环境 这是非常关键的一步，好的开始就成功了一半。配置sass环境是件比较痛苦的事，因为你要装很多东西。 ##安装ruby 众所周知，sass是用ruby编写的一个产物，那么肯定少不了你的机器上得有ruby环境。由于我是OSX系统，系统一开始已经预置了ruby环境，所以在这里我先就不介绍怎么配置ruby环境（等我去找个windows环境，然后把windows的配置给补上） ##安装sass 打开终端，键入命令 gem install sass 等待安装完毕 ##安装compass 想要发挥sass的优势，必不可少的就是compass，同样，跟安装sass一样，继续键入命令 gem install compass 等待安装完毕 这两个安装完成后，键入命令 gem list 可以查看到你所安装的模块 ##配置config.rb 想要在项目中正常的使用sass，config.rb文件必不可少 See the Pen yNrRLZ by WangWenyu (@Jacobwang) on CodePen. 项目根目录新建config.rb文件，把上方代码粘贴进去。前三行是引入一些必要的sass模块。http_path = “/“css_dir = “dist/css”sass_dir = “src/sass”images_dir = “dist/images”javascripts_dir = “src/js” 这一块是配置sass文件编译生成对应的目录。 接着打开gulpfile.js文件，找到这句代码 var gulp = require(&apos;gulp&apos;); var compass = require(&apos;gulp-compass&apos;); 这一句是引入gulp和gulp-compass模块。为什么在这里我不用gulp的sass模块，因为我在这里引入了网格系统susy，用sass的那个模块，编译susy根本通过不了，无奈之下只有退而求其次选择了gulp-compass这个 //compass gulp.task(&apos;compass&apos;, function() { gulp.src(&apos;./src/sass/main.scss&apos;) .pipe(compass({ config_file: &apos;./config.rb&apos;, css: &apos;dist/css&apos;, sass: &apos;src/sass&apos;, require: [&apos;susy&apos;] })) .pipe(gulp.dest(&apos;./dist/css&apos;)); }); 接着找到这一段话，src方法中传入了对应的要编译的sass文件路径，接下来通过刚才的config.rb文件，获取定义的sass编译信息，系统会找到对应的compass模块的位置，进行编译输出css文件。接着看到这段代码 gulp.task(&apos;default&apos;, function(){ gulp.run(&apos;compass&apos;); gulp.watch(&apos;src/sass/*/*.scss&apos;, [&apos;compass&apos;]); }); 这段代码就是配置gulp一开始的运行的任务，以及gulp所监听的文件改动，这里运行了compass这个任务，跟上面定义的任务名一致，写好gulpfile之后，终端打开键入命令： gulp 即可运行gulp，记住保持终端的运行，不要关闭窗口。之后你在对main.scss这个文件每次修改保存后，gulp就会自动编译生成对应的css文件，非常方便。希望大家在使用gulp插件的过程中可以根据刚才的compass插件的使用举一反三，插件的用法基本上都是一样的。 下一篇我会介绍自动刷新大法，敬请期待！","link":"/2015/08/15/前端集成解决方案实践（二）/"},{"title":"前端集成解决方案实践（一）gulp的基本使用","text":"前端集成解决方案是近一两年内炒的比较火的话题，无论是在微博上，在知乎上，以及各种微信公众号，各大技术分享会上，多多少少都会出现前端集成解决方案这样的话题。究竟什么是前端集成解决方案呢。 #开篇 所谓Front-end Integrated Solution（前端集成解决方案），就是对前端开发团队在日常开发的过程中，所经历的几大阶段做一整个集成，由于我写这篇是实践文，所以我直接借助百度前端团队的一个介绍点击查看百度前端团队 #说说要介绍点啥 这次我所分享的是我在近三个月的几个项目中的实践总结，主题就是使用gulp+sass无痛编写网页，重点是介绍gulp的使用。所以这篇文章是写给有一定开发基础的前端看的。 #现在开始吧 废话不多说，开始进入正题。 ##为什么要使用gulp？ 一般前端开发流程中，页面的编写是必不可少的环节，一般的做法就是建立一个项目文件夹，里面放上例如css，html，images这样的文件夹，存放项目中所使用到的相关文件，在编写过程中，每编写一段代码就要去手动刷新一次页面，非常麻烦。每次做雪碧图的压缩定位也是一件繁琐的事情，还有项目最终的代码检查，代码打包压缩等等诸如此类的前端开发环节。我们一直在寻找有没有一种方式可以帮我们全自动的跑通这个环节，自动的刷新页面，自动的压缩代码，自动的加上浏览器前缀，自动的做代码检查等等。这个时候，gulp的出现帮助我解决了这一大问题。 ##如何使用gulp？ gulp是依赖于nodejs环境的，所以使用的时候就是需要通过npm的安装方式进行安装。node的环境配置在这里我就不多说了。具体参考这篇教程nodejs环境的搭建以及npm的安装教程 安装好nodejs之后，windows系统打开cmd命令终端，输入命令： npm install gulp -g mac系统打开自带的终端程序，输入命令： sudo npm install gulp -g 此时会让你输入管理员密码，输入密码之后敲击回车。安装成功的截图如下： 安装成功之后，在你的项目文件夹根目录建立gulpfile.js文件，代码如下： See the Pen rVbrey by WangWenyu (@Jacobwang) on CodePen. 打开终端，在终端中进入这个文件夹，键入命令： npm init 将你的项目进行初始化，确定你所需要的依赖项。基本上是一路enter。 再打开package.json文件，添加项目中所需要的npm依赖项 See the Pen yYEJXK by WangWenyu (@Jacobwang) on CodePen. 再次键入命令： npm install 开始安装之前配置的依赖项。在经过漫长的等待安装完一堆依赖项之后，再次键入命令： gulp 此时gulp已经运行起来了 到此，我们已经完成了gulp的使用介绍，我会在下一篇里面介绍如何通过gulp编译sass文件以及介绍使用一个神器livereload。 在这里我们来分析下gulpfile.js这个文件里面的代码。首先是通过require()方法加载所需要的npm模块，接着通过gulp.task编写一个任务，里面传入两个参数，第一个是自行定义的方法名，第二个是回调函数，里面写入执行该任务的方法。接下来看每个任务里面的方法，pipe的作用是让你可以链式的调用gulp的各种插件。具体每个插件的用法在npm网站上搜索对应的插件名，就可以看到对应的用法文档：例如，我们搜索gulp-compass，打开npm网站搜索gulp-compass插件，可以看到。 gulp.run方法的作用是运行gulp任务。 gulp.watch方法作用是监听任务，可以在对应监听的文件改动后自动再次运行该任务，来达到自动化的效果。 我这里使用到的几个gulp的插件功能基本上是合并文件，代码检查，文件压缩重命名，sass文件编译压缩，自动监听刷新页面。","link":"/2015/10/30/前端集成解决方案实践（一）/"},{"title":"如何在gulp项目中优雅的使用ES6","text":"安装第一步就是要安装gulp-babel 1npm install --save-dev gulp-babel 使用12345678var gulp = require(\"gulp\");var babel = require(\"gulp-babel\");gulp.task(\"default\", function () { return gulp.src(\"src/app.js\") .pipe(babel()) .pipe(gulp.dest(\"dist\"));}); 创建 .babelrc 配置文件到刚才那一步，babel并不能成功运行，这时候需要在项目根目录添加一个.babelrc文件，启用一些插件，接下来再安装一个插件 1npm install babel-preset-env --save-dev 安装成功后，在.babelrc文件中这样写 123{ \"presets\": [\"env\"]} 我在实际使用过程中发现了，以上的配置并不能转换解构赋值的特性，所以还需要安装另一个插件 1npm install babel-preset-stage-0 --save-dev 在.babelrc文件中这样写 123{ \"presets\": [\"env\", \"stage-0\"]} 一切正常运行。","link":"/2018/06/28/如何在gulp项目中优雅的使用ES6/"},{"title":"微信小程序rich-text富文本图片自适应处理","text":"最近在小程序开发中遇到个问题，在使用后台传递过来的富文本编辑器里的内容进行展示的时候，遇到了图片无法自适应的问题，尝试修改img,image标签的样式，都没有作用 无奈之下，只有尝试replace过滤大法 1data.content.replace(/\\&lt;img/gi, '&lt;img style=\"max-width:100%;height:auto\" '); 搞定。","link":"/2018/06/10/微信小程序rich-text富文本图片自适应处理/"},{"title":"浅谈我在前端自动化工作流中的实践","text":"现如今的前端真的是百家争鸣，百花齐放。各路新奇的技术，框架层出不穷，Javascript这门编程语言也被推向了神坛。Javascript在前端，后端，客户端各个领域都想要蚕食一块资源，为前端开发者们带来了新的春天，让很多切图仔们摇身一变，变成了神坛之上的所谓的前端大佬。前端自动化工作流正是这众多前端发展道路上耀眼的一个领域。 切图仔的饥荒年代在前端自动化一词还未出现在我的眼中之前，我的工作中有这样几个痛点 html代码无法复用，无法很便捷的使用后台语言的include模版 由于浏览器厂商之间的明争暗斗，导致了css3属性兼容代码的多样性 各种雪碧图的生成，css代码的自行定位生成 写完一段代码，就要手动保存，手动刷新浏览器去查看，还可能受到本地缓存的困扰 各种代码，资源文件的压缩，加版本号 代码的语法检测 开发环境和生产环境的代码分离 在实际的开发过程中，这些痛点很多时候都因为项目时间不够，一般都是没做，或者通过很多敷衍了事的办法，匆忙上线，这就直接导致了代码的混乱，可维护性差。 希望的曙光随着nodejs的出现，前端攻城狮们将手伸向了不曾也不敢触碰的服务端领域，在服务端上大放异彩，可以用Javascript来操作本地文件了，可以开启子进程对文件进行处理了，可以处理http请求了。这时，我遇见了Grunt Grunt算是前端自动化工作流早期的一个项目了，也算做是一个元老了，距离它的第一个版本发布差不多已经走过了五个春秋，不过至今市面上还有很多开源项目中使用了Grunt。我对Grunt了解的不太深入，大概只经历了10个以内的项目，因为Grunt有个痛点，就是配置文件略微繁琐 Grunt是配置和运行分离，每一个task做的事情非常多，而且配置项也很多，就像如今的webpack(间接黑了一把webpack) 长江后浪推前浪既然Grunt饱受诟病，那么就再造个轮子吧。于是，Gulp出现了。 Gulp在经历了4年光辉岁月之后，走到了今天的4.0版本，我也跟着从0.x用到了今天的4.0。Gulp仅拥有6个API，核心的概念就是管道，相信有过Unix经验的同学一定对管道哲学的概念印象很深，以”链式模型”来组成一条直线工作流。 Gulp也拥有丰富的插件，这些插件就解决了我之前的几大痛点 gulp-file-include 复用html模版 gulp-minify-css 压缩css gulp-sass sass编译 gulp.spritesmith 雪碧图自动生成图片，并同步生成sass代码 gulp-uglify js代码压缩 gulp-autoprefixer css3 属性自动添加前缀 在编写好gulpfile.js的配置文件之后，在命令行中打开项目根目录路径，运行gulp的启动命令之后，一系列的工作流就会自动运行，在你对文件进行每一次更改之后，gulp都会执行对应的任务，妈妈再也不用担心我的工作烦恼了！ 虽然这种工作流用起来很爽，但是每次新建项目的时候又是一个痛点，每一次还要把上一个项目复制过去，再执行一次例如npm install安装依赖的动作，这样次数多了，我又开始觉得麻烦了(os：我这人就破事多)，于是不甘寂寞的我写了个项目生成器 耐损度36的王族之剑Yeoman是一个强大的前端构建工具，是前面提到的Grunt的好基友，它的作用是什么呢，可以让你的脚手架变成一个模版，通过Yeoman来创建项目，这样，我们就可以使用一个命令来达到初始化创建项目的目的。Yeoman官方提供了一系列的api，你可以自己开发一个generator，我利用它写了个自己的generator，先贴个地址generator-hllui 有此神器之后，切图的效率真的是大幅度的提升，可以让我更加专注地在切图上，免去了很多其他工作的重复消耗 但是，这个工具在我们团队使用了一段时间之后，我发现了一个问题，就是有些同学记不住命令，或者经常有命令输错的情况，还有很多次命令行工具挂掉的问题。我就想着如何去改进，在某个深夜撸码的时候，下了个决心，决定自己造一个可视化脚手架轮子 拔出了打boss的大师剑我用ELectron+React写了个桌面端应用，这是一个本地脚手架工作平台，是为了应对多元化的业务需求，也是为了能让团队其他前端同学在属于他们自己的领域大放异彩。 我给它起了个名字，叫Dotflow，手机上一直装着的一个游戏，叫dots，通过连接相同颜色的点，来组成一个回环，消失得分。当所有的点都连在一起的时候，就会行成一条线，虽然过程有所曲折，但是终将会走到终点 工作流只是这个应用的其中一部分，工作流内置了我编写的日常使用的脚手架，当这些脚手架满足不了你内心膨胀的欲望的时候，你可以选择添加一个git repo脚手架，也可以添加一个本地脚手架。当然这些脚手架模版还是有一点规范要求的。这里的脚手架已经不局限于基于Gulp的工作流了，你可以添加基于webpack的，基于rollup的，甚至更多适合你自己的脚手架，只要对你的脚手架稍加改造，就可以在这个平台上运行起来 添加脚手架之后你可以选择需要的脚手架新建一个项目，或者你可以在本地导入一个现有项目，是不是很方便 我还将命令行运行这个过程可视化了，通过点击几个按钮，立马就可以启动项目，又可以愉快的写代码了～～ 新的篇章已经开启从石器时代到如今的后帝王时代，一路升级打怪，前端在这几年真是出了太多的轮子，当然，这一切都是为了提升效率，让前端圈更加的繁荣发展，毕竟，科学技术是第一生产力。 相关资料 Grunt Grunt Gulp Gulp Yeoman Yeoman Webpack Webpack Dotlow Dotlow","link":"/2018/06/10/浅谈我在前端自动化工作流中的实践/"},{"title":"用Hexo搭建github博客","text":"之前本来想写一篇这个的，发现自己还是没有这个耐心写下去。。因为太多了。。。而且别人也写好了，附上一个地址收藏一下吧 点击即可查看","link":"/2015/04/24/用Hexo搭建博客/"},{"title":"移动端touch事件关于滑动页面的相关bug","text":"上半年我在做移动端开发的过程中，踩坑无数。（其实是自己任性使用各种没用过的技术投产到项目里去，自己给自己挖了一堆坑。。）其中有一个大坑就是在模拟webapp的时候，做了一个listview，就是列表浏览。 首先，我们先看两张图，演示一下这感人的效果 ##一张是这个，这是淘宝模特效果 ##另一张长这样，这是买家上身效果 坑爹呢这是！！！！！！！为毛我滑动屏幕的时候会触发那个容器弹出啊！弹出啊！出啊！啊！ #bug为什么会出现呢 现在我们用的移动端浏览网页的设备多数都是触摸屏，这就跟我们平时在pc端浏览页面大不一样。所以我们在制作一些网页效果的时候就会用到一个名为touch的事件。 touch事件里面一般来说有三种：touchstart，touchmove，touchend。字面上翻译过来就是，触摸开始，在触摸屏上滑动，触摸结束。 我们在用手指触摸屏幕进行网页浏览的时候，会经历这样的一个过程，手指接触到屏幕（touchstart），手指在屏幕上滑动（touchmove）浏览完手指离开屏幕（touchend）。 问题就在这个过程中出现了，你对你的每个list添加了个touchend事件监听，监听点击这个列表项的时候，触发另一个舞台场景的切换，也就是你放置列表详细内容的容器。本来，这一切都是那么的美好。。但是，你有没有想过，你在滑动屏幕的时候，手指离开的之后，浏览器也会触发你的容器切换事件呢？ 稍微的思考一下，就会知道，它会触发的，而且触发的几率几乎高达百分百、、、就是图2所示的。 #出现bug总要解决吧 我确实是解决了这个问题，但是解决方案我感觉有些low逼、、跪求大神提出更好的解决思路 解决的源码我在最后给出了，代码很简单，非常好理解。并且附上了解决之后的地址 我在这里就说下我的解决思路（以下提示的代码我只提取核心内容，具体源码看最下方的codepen）： 先获取触摸开始的位置，这个很好获取 var _self = this; for(var i = 0;i&lt;_self.targetNode.length;i++){ _self.touchEvent(_self.targetNode[i],&apos;touchstart&apos;,function(e){ _self.startX = e.touches[0].pageX; _self.startY = e.touches[0].pageY; }) } 2.再获取触摸结束的位置 var _self = this; _self.touchEvent(_$(&apos;body&apos;),&apos;touchmove&apos;,function(e){ e.stopPropagation(); //获取滑动的的位置 _self.moveX = e.touches[0].pageX; _self.moveY = e.touches[0].pageY; //获取触摸结束的位置 _self.lastdisX = _self.startX-_self.moveX; _self.lastdisY = _self.startY-_self.moveY; }) 3.最后开始位置与最后位置相减，如果相等的话，说明用户只在页面上触发了触摸点击事件，并没有滑动，如果不相等，说明用户触发了页面滑动事件 var _self = this; for(var i = 0;i&lt;_self.targetNode.length;i++){ _self.touchEvent(_self.targetNode[i],&apos;touchend&apos;,function(e){ e.stopPropagation(); _self.disX = _self.startX-_self.moveX; _self.disY = _self.startY-_self.moveY; //检测是否是同一个位置 if(_self.lastdisX == _self.disX){ //滑动过程触发的事件 }else{ //非滑动，单纯触摸触发的事件 } }) } 4.这里我要说一下，位置的(0,0)点是在屏幕的左上角，这个跟canvas的坐标点位置也是一样的，所以越往下，坐标取值就越大。 See the Pen qdwyNx by WangWenyu (@Jacobwang) on CodePen. 以下是解决方案的完整源码，这里我用了个闭包将其封装起来。代码仅供参考，主要是要理解解决的思路，这样才能举一反三，将代码改动一下用在自己的项目里。千万不可一知半解，这样会白白浪费很多时间。线上测试地址，在移动端模拟器里面打开","link":"/2015/09/10/移动端touch事件关于滑动页面的相关bug/"},{"title":"第一篇博客","text":"前几天突然意识到自己在技术发展的道路上再不有所沉淀是不行了，之前就一直吵着要写博客，但是因为各种原因总是迟迟不去写，说白了，拖延症晚期。。不过还有得治 放张十元的照片让大家陶醉一下先，哈哈 一 上个月是招聘旺季，俗称抢人月，看到那么多互联网公司用高薪吸引人，我心里也有点触动，也想赶上这浪潮去掀一番风浪。但在几个晚上的思考中，觉得不能被这浮躁的社会所影响，自己还是需要有所沉淀。不知道哪来的激情，上个月竟然花在Github上的时间非常多，虽然没有贡献多少代码，但还是在Github上看到了很多优秀的开源项目。看着几个好友的Github上花花绿绿的，再看看自己的，白花花的一片。虽说一白遮百丑，但是，这是形容姑娘的，作为全世界最大的同性交友社区Github，你的白只能证明你在这社区里的活跃度不够高。 其次，我发现我刷知乎所耗费的时间越来越多，不过也好，也看到不少前辈们说的话。总之，搞技术的，没点技术沉淀，你上哪唬人去？ 二 我果然是个话痨，无救。 既然是第一篇博客，本博客又是技术博客，所以什么展望那都是扯犊子，发条说说也就完事。 其实博客程序我也接触到很多，去年一直热衷于Wordpress这个博客程序，公司的几个项目都是Wordpress搭建的。不得不说Wordpress真的很强大，我用这个程序做了个CMS网站，三个公司官网。wp的主题制作起来还是很顺手的，不过必须得有点php的基础，不然你都不知道wp的方法是怎么调用的。说道wp内置的各种方法，那真是非常强大，如果自带的那些方法不够你用，那么你可以在主题里面扩展方法，当然，你得会写php，这个真不是骗你。wp主题在这里先简单说说吧，以后我会写一篇详细的博客来说下这些主题的制作。自己也用Wordpress搭建了一个博客，但是那时就是沉不下心来去写博客，可能因为自己的玩心太重吧。 之后在去年快年底的时候，接触到了nodejs这块。自然而然的也就接触到了nodejs的博客程序。首先接触到的就是Ghost这个，看到它的第一眼我就喜欢上它了。设计非常简洁，而且操作起来也很便捷。最重要的是它是Wordpress的那帮制作团队的产物。Ghost是用Handlebars.js作为模板引擎Handlebars学起来也比较顺手。由于Ghost我了解不多，在这我也就不多说了。 最后来说说Hexo这个程序。本博客就是用Hexo搭建的。Hexo也是一款nodejs程序。我将它搭建在了Github上，这里有同学一定会困惑，Github上还能搭建博客?没错，Github上确实能搭建博客，而且还很方便，怎么样，是不是突然就感觉逼格很高。没关系，我会写一篇文章教大家如何玩转Github！回到Hexo上来，就在上个星期，我下定决心要开始写博客了，自己的阿里云服务器也快到期了，所以就在Github上搭建了博客，知乎上逛了一圈，都说Hexo这个程序不错，于是就决定试着用用看。安装过程什么的都很顺利，由于前端职业病，直接去看了Hexo的主题制作的API，官方也没有什么详细的说明。没办法，只能clone一个别人做好的主题，一探究竟。打开主题文件，发现Hexo的主题文件很特别，使用ejs模板做的，这也非常符合nodejs的风格。至于样式，使用了是Stylus这个小玩意。花了一晚上，把ejs和Stylus的用法看了下，决定第二天上班的时候抽空设计套主题。真是说干就干啊。第二天用Sketch设计出了一套主题，在这里强烈推荐Sketch这个软件，做web设计简直是一绝，不过只能在Mac系统里面用，有点可惜。。 三 我就具体说说我制作主题这个思路。 首先，我个人非常喜欢简洁的设计风格（其实是复杂的不会做，找了个借口，哈哈哈）。简洁风会给人一种干净整洁的感觉。于是，我就把整个主题设计成黑白灰三种颜色。（技术人员就不要搞些花花绿绿的，不要搞些奇形怪状的）。其实我不是很喜欢设计这些东西，作为一名前端工程师，愿意自己把更多的精力放在前端技术上。至于这个博客的技术点，用了时下比较流行的响应式设计，就是兼容三屏浏览。用了CSS3里面的一个字体的引用，给整个博客增添了一点风采。别的技术点也没什么，由于是主题，在Javascript上也没什么太多的炫技。我觉得之后非常有必要去做个CSS3动画炫酷版本，哈哈，这也是后话了。小控件上，借助了Github的API，把你在Github的个人信息调用了过来,至于Stylus的易用性，让我们在编写css上更具有模块化思想。制作这个主题多多少少也遇到了不少坑，比如调用多说的评论插件，官方文档说的不明不白的，真是一大坑。标签云这块，之前看到有位大神的博客的标签云很有意思，于是就仿造了他的标签云。整个博客主题从构思到设计到制作花了不到两天时间，都是抽空做的，第一个版本，难免有些粗糙。后期我会一直更新这个主题，准备给这个主题加点动画上的交互，增加点友好性。 四 没想到第一篇博客咔咔咔的敲了这么多字，也是不容易，对我来说真的是个很好的开端。可能文字不够成熟，但是随着岁月的流逝，时间的推移我相信我一定会有所沉淀的。谁都有颗想成为大神的心，一万小时也不是梦，坚持下去，一定会有所收获。 五 不能忘了，我得放上本博客主题的在github上的链接 https://github.com/wenyuking/Hexo_Theme_Concise","link":"/2015/04/14/第一篇博客/"},{"title":"PostCSS系列(一)-关于PostCSS那些事","text":"关于PostCSS，如果真的有一件事你必须要去做的话，那就是尽可能的学会使用它。 在这个系列中，我们会带你深入了解关于PostCSS在日常工作中的常见用法。如果你还没有准备好让你的大脑接受PostCSS这个新事物的话，那么请鼓起勇气，我们将带你进入一个全新的CSS世界。 本文翻译自：http://webdesign.tutsplus.com/tutorials/postcss-deep-dive-what-you-need-to-know–cms-24535 ##先介绍介绍PostCSS PostCSS的受欢迎程度正在以一个极快的速度增长着，越来越多的人们开始明白，PostCSS可以为他们做些什么，他们认识到了这个工具以一种独特的方式运用在他们的项目里，并且他们非常享受这份快感。 在2014年的一整年中，这个项目一共有140百万的下载量，然而到了2015年1月-6月的这个时间段，这个项目的下载量已经超过了380万次。 Autoprefixer,一个非常受欢迎的PostCSS插件，Google，Shopify，Twitter，Bootstrap，CodePen，WordPress等等大型的项目中都使用到了Autoprefixer这个插件。以及RTLCSS这个插件。Alibaba公司也使用了很多PostCSS插件，而且他们的工程师还为PostCSS贡献很多高质量的插件。 在这之前， Mark Otto已经表示Bootstrap的第五个版本将会使用PostCSS去编写 Oh, btw—Bootstrap 4 will be in SCSS. And if you care, v5 will likely be in PostCSS because holy crap that sounds cool. — Mark Otto (@mdo) April 23, 2015 PostCSS在CodePen.io社区中已经被支持使用 PostCSS正在成长，正在以一个飞快的速度成长，所以，你没有任何理由不去使用它。 ##简单说下什么是PostCSS吧 前面说了这么多，你们一定会困惑，什么是PostCSS呢？我想，最好的解释不过于他们在GitHub项目的主页上的简介了吧。 PostCSS is a tool for transforming CSS with JS plugins. These plugins can support variables and mixins, transpile future CSS syntax, inline images, and more. PostCSS是以一种JS插件形式目的是为了转换CSS的工具，这个插件支持变量，混合宏，添加浏览器前缀，合并图片等功能。 简而言之，PostCSS将CSS转换成了一种JavaScript可以操纵的数据，以JavaScript为基础的PostCSS就可以直接运行这些代码操作。PostCSS并不会改变你的CSS，它只是设计出了一套转换方式，以至于可以更好的将PostCSS代码转换成CSS代码。 从本质上来说，PostCSS插件并没有对转换CSS代码这方面做了太多的限制，也就是说，你可以开发出很多具有特色并且非常实用的插件。 PostCSS 的插件就像预处理器一样，它可以优化和自动补全你的代码，可以添加浏览器前缀，可以做代码执行检测，可以设置变量，可以提供一套完整的栅格化系统，也可以提供一些代码片段。还有很多很多就不一一列举了，其他一些实用的功能还等待着你的创造。 ##那PostCSS又不是什么呢 事实上，你可以借助PostCSS插件做任何事，但实际上，PostCSS仍然是个新生儿，有些用法确实给人们带来了不少的困惑。 许多人(也包括我自己)，对PostCSS并没有一个非常完整的印象，因此肯能就弄不清楚哪些是PostCSS可以做的，哪些又是PostCSS做不了的。 所以，在继续出发之前，我们先来理清楚PostCSS不是哪些东西 ###首先，PostCSS不是一个预处理器 许多开发人员说他们放弃支持PostCSS CSS的预处理器。与此同时其他国家,因为他们更喜欢他们不喜欢PostCSS当前预处理器。然而PostCSS不是一个预处理器。 是的,你完全可以把它作为一个预处理器,如果你愿意,但你也可以使用PostCSS绝对没有preprocessor-like功能。你甚至可以继续使用你最喜欢的预处理器结合PostCSS。 ###PostCSS不是一个后处理器 PostCSS虽然带有“post”这个词,但它不是一个真正“后处理器”。后处理通常被视为在加载完样式表，包含有效的/标准的CSS语法和处理它,做些例如添加前缀这些事。然而PostCSS并不局限于仅仅以这种方式操作。正如上面提到的,它更像一个预处理程序。 目前来说，对PostCSS最好的描述就是他是一个”处理器”。PostCSS的作者Andrey Sitnik在Twitter上这样说到： It is time admit my mistakes. “Postprocessor” term was bad. PostCSS team stoped to use it. https://t.co/vs2AiXGoJy— PostCSS (@PostCSS) July 28, 2015 （原文这段话有些绕口，简单来说，PostCSS就是CSS身前的男人） ###PostCSS不是一个新颖的语法 你会发现，有一些众所周知并且非常优秀的插件允许你使用一些新颖的语法，但这些新颖的语法并没有得到广泛的支持。 ###PostCSS不是一个清理/优化工具 ###PostCSS什么都不是（原文这段确实没啥意义，稍微看看就行了） ##那PostCSS又有什么特殊的地方吗 PostCSS对于CSS来说，是一个新颖的东西，我给他的一个描述就是CSS的瑞士军刀，我觉得这个描述非常到位，完美！ 让我们来看看PostCSS到底有哪些不同： ###PostCSS插件的生态系统圈提供了不同的功能 你再PostCSS GitHub page上可以看到很多你闻所未闻的插件功能。 这些插件都使用了一种新颖的语法，允许你使用像颜色方法，梯度渐变，自定义选择器，自定义属性，自定义媒体查询，自定义你想自定义的。 当然还有些插件是为了给旧语法做兼容的，比如兼容rgba()这个属性，给IE8及以下版本加了个透明度的滤镜，兼容了IE8及以下版本不支持的选择器，rem方案用px代替兼容等等。 超过20种语言扩展插件是可以使用的，例如mixins, variables, conditionals, for and each loops 还有很多，具体的看check out the list这个吧 ###非常模块化的，你可以选择你想用的 PostCSS是由一堆插件组合而成的一个凌驾于CSS之上的加强版CSS生态系统圈(这是我的个人理解，不喜勿喷。。)，由于插件的独立性，所以模块化的使用就愈发的清晰，你可以挑选你想用的插件组合起来，来一场只属于你一个人的完美战斗。 ###编译解析速度奇快无比 小米公司的雷布斯最擅长的就是不服跑个分，PostCSS也来了个性能跑分测试，具体你可以到这里查看详细的跑分信息 PostCSS: 36 ms Rework: 77 ms (2.1 times slower) libsass: 136 ms (3.8 times slower) Less: 160 ms (4.4 times slower) Stylus: 167 ms (4.6 times slower) Stylecow: 208 ms (5.7 times slower) Ruby Sass: 1084 ms (30.1 times slower) 这样一对比，结果很明显，Sass你个low逼简直不忍直视！ ###你可以创造你想创造的插件 还是那句话，PostCSS给了我们无限的遐想，正是因为有了这样的自由，我们才能解放天性，玩得更嗨。所以这一刻，让我们手拉手心连心共同创造出更多美好的插件吧，造福社会，你我共赢。 ###你还可以直接使用CSS 既然凌驾于CSS之上，当然对于CSS就有完美的包容性 ###PostCSS不借助于任何一个预处理器或者后处理器 经常看到一些ROM包基于安卓开发什么的，也就是说，安卓有的缺点，你还是有。但是PostCSS就不依赖于任何一个处理器，让那些繁琐复杂的处理器都去见鬼去吧！ ###PostCSS可以使用一些很新潮的工具开发 1.可以写成Grunt, Gulp, webpack, Broccoli, Brunch and ENB的插件 2.CodePen 允许使用PostCSS 3.Prepros支持了Autoprefixer and cssnext插件 4.使用npm install命令安装这些插件 ##说了这么多，让我们来回顾一下 回顾个毛线啊，一整篇没啥卵用啊！下一篇将会直接上实战。理论知识什么的最无聊了。。","link":"/2016/02/10/PostCSS系列(一)/"},{"title":"使用React构建Electron应用-入门踩坑篇","text":"最近几个晚上都在编写dotflow(一个前端工作流平台)，想尝试一次新技术，就选择了React+Electron技术栈。React是一个前端UI渲染框架，结合React全家桶做SPA也是一把好手；Electron是基于Nodejs的一个编写客户端软件的框架，ps:呵呵，万能的js。 一开始React方面看中了阿里的轮子antDesign+umi,然而在经历了三天的尝试之后弃坑逃跑，后面专门留一段说为什么会弃坑。 初始化项目首先我们需要依赖fb官方推荐的React应用构建脚手架create-react-app。以下简称cra根据文档说明，我们成功创建了项目之后，本地的目录结构应该是这个样子的 这里我的编辑器使用的是vscode，我们可以直接在编辑器里面直接打开终端，运行命令yarn start,运行成功后，浏览器会打开一个页面，像下面图片所示： 接下来的步骤很关键，cra的封装性做的非常好，你可以不用修改任何配置文件就可以完成一个React应用的开发，当然我们这里是需要修改很多配置文件的，我们新建一个终端标签页，输入yarn eject根据提示完成之后，就会看到文件目录里多了很多文件，这些文件就是项目所有预置的配置文件。这时候，你还需要执行一次yarn命令，来完成所有npm包的安装。项目初始化已经完成。 集成Electron第一步初始化项目如果你完成的很顺利的话，我们进入第二步，把Electron集成进去。接下来我们开始大刀阔斧地改动项目文件 two-package-structure按照ELectron的约定，最佳实践是使用two-package-structure结构来构建应用，我们分别在src目录下分别建立main和renderer文件夹,然后把之前src目录下的文件全部放入renderer文件夹中，然后在main文件夹下建立我们客户端开发需要的业务文件，这里可以参考我在github上的示例代码，我将客户端业务全部写成多个services，通过全局global暴露出去。在renderer端使用remote形式对services进行调用，具体的不在这里赘述，后面开新篇具体说明原理。 项目根目录新建app文件夹，具体文件参考github源码 修改配置文件 package.jsondependencies参考github上的源码script参考如下代码 12345678910\"scripts\": { \"postinstall\": \"cd app &amp;&amp; tnpm i &amp;&amp; cd .. &amp;&amp; npm run rebuild\", \"start\": \"concurrently \\\"node scripts/start.js\\\" \\\"npm run build:electron\\\"\", \"start:electron\": \"electron app/dist/main\", \"build\": \"node scripts/build.js\", \"build:electron\": \"node scripts/electron.js\", \"rebuild\": \"electron-rebuild ./app\", \"pack\": \"npm run build &amp;&amp; npm run build:electron &amp;&amp; npm run rebuild &amp;&amp; electron-builder\", \"test\": \"node scripts/test.js --env=jsdom\"}, config配置文件将config/paths.js文件里面的几个配置分别作对应的修改，代码如下： 1234567function getServedPath(appPackageJson) { const publicUrl = getPublicUrl(appPackageJson); const servedUrl = envPublicUrl || (publicUrl ? url.parse(publicUrl).pathname : './'); //这里修改webpack的publicPath为了让electron打包之后能访问到页面 return ensureSlash(servedUrl, true);} 1234//修改入口目录文件appBuild: resolveApp('app/dist'),//更改build的outputPathappIndexJs: resolveApp('src/renderer/index.js'),appSrc: resolveApp('src/renderer'), 在config文件夹下新建webpack.config.electron.js文件，添加如下代码 12345678910111213141516171819202122232425262728const path = require('path');const webpack = require('webpack');const paths = require('./paths');module.exports = { target: 'electron-renderer', entry: { main: './src/main/index.js' }, output: { path: paths.appBuild, filename: '[name].js' }, externals(context, request, callback) { callback(null, request.charAt(0) === '.' ? false : `require(\"${request}\")`); }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: 'babel-loader' } ] }, plugins: [new webpack.DefinePlugin({$dirname: '__dirname'})]}; 这里简单说一下，这个webpack配置文件是打包electron业务代码到app/dist文件夹下 为了让命令执行和cra之前的方式统一，在scripts文件夹下面建立electron.js 这个脚本是执行刚才建立的webpack.config.electron.js的任务的，脚本我已写好，贴上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364'use strict';// Do this as the first thing so that any code reading it knows the right env.process.env.BABEL_ENV = 'production';process.env.NODE_ENV = 'production';// Makes the script crash on unhandled rejections instead of silently ignoring// them. In the future, promise rejections that are not handled will terminate// the Node.js process with a non-zero exit code.process.on('unhandledRejection', err =&gt; { throw err;});// Ensure environment variables are read.require('../config/env');const path = require('path');const chalk = require('chalk');const webpack = require('webpack');const config = require('../config/webpack.config.electron');const formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');// Create the production build and print the deployment instructions.function build() { console.log('正在编译打包electron-renderer...'); let compiler = webpack(config); return new Promise((resolve, reject) =&gt; { compiler.run((err, stats) =&gt; { if (err) { return reject(err); } const messages = formatWebpackMessages(stats.toJson({}, true)); if (messages.errors.length) { if (messages.errors.length &gt; 1) { messages.errors.length = 1; } return reject(new Error(messages.errors.join('\\n\\n'))); } if (process.env.CI &amp;&amp; (typeof process.env.CI !== 'string' || process.env.CI.toLowerCase() !== 'false') &amp;&amp; messages.warnings.length) { console.log(chalk.yellow('\\nTreating warnings as errors because process.env.CI = true.\\nMost CI servers se' + 't it automatically.\\n')); return reject(new Error(messages.warnings.join('\\n\\n'))); } return resolve({stats, warnings: messages.warnings}); }); });}build().then(({stats, warnings}) =&gt; { if (warnings.length) { console.log(chalk.yellow('Compiled with warnings.\\n')); console.log(warnings.join('\\n\\n')); console.log('\\nSearch for the ' + chalk.underline(chalk.yellow('keywords')) + ' to learn more about each warning.'); console.log('To ignore, add ' + chalk.cyan('// eslint-disable-next-line') + ' to the line before.\\n'); } else { console.log(stats.toString({ chunks: false, // 使构建过程更静默无输出 colors: true // 在控制台展示颜色 })) console.log(chalk.green('✨ 编译 成功.\\n')); }}); 新增开发者工具项目根目录新增extensions目录，这里面放置electron内置的开发者工具，我在github连接上预置了redux-devtools，由于我的电脑无法编译最新版的react-developer-tools工具，所以我将这个工具调用代码注释了 重新运行在更改完文件夹，修改完一堆配置文件之后，这时候我们重新在终端中运行yarn start 如果成功运行的话，浏览器会出现一开始打开的界面 我们新建一个终端标签页，运行yarn start:electron，如果成功运行的话，本地会弹出一个应用程序调用，你会看到下面图片上的画面这时在react和electron的集成构建应用我们就完成了 打包应用新建终端标签页，执行命令yarn run pack,执行成功后，我们可以看到终端运行情况此时正在打包中 打包完成后，我们在项目根目录可以看到生成了一个dist文件夹，这里就是构建成功的app文件 安装成功后，测试成功运行 示例文件electron-react-example 总结最后说一下我为什么弃坑umi，不是说umi不好，umi是个很优秀的框架，是dva框架作者今年新的目标，主要是umi在打包之后，对file://协议对象解析不好，electron窗口运行又是依赖file://协议的。作者应该也没有精力在这上面。总之这几天真的是踩了太多的坑。我后面计划从最原始的react全家桶开始搭建，开始慢慢踩坑。这也是我要做dotflow这个应用的原因，为了找到最适合自己的那个点。 参考文章 create-react-app Electron 应用实战 (架构篇)","link":"/2018/05/08/使用React构建Electron应用-入门踩坑篇/"},{"title":"在Wordpress主题中使用AngularJS自定义指令","text":"第三章：在Wordpress主题中使用AngularJS自定义指令 本文翻译:Use AngularJS Custom Directives In A WordPress Theme 在上一篇文章中，你应该学到了像和ng-repeat这样的HTML标签或者一些属性，在AngularJS中，这个被称作是指令构造器。事实上，你所学到的一切以”ng”开头的属性或者HTML标签之类的，都是来自AngularJS。一般来说，我们在自定义指令或者方法的时候，可以没必要以”ng”开头。 长话短说，“directives”指令是AngularJS操纵DOM的一种方式，他们看起来像HTML标签或者属性，使用起来也和HTML标签或者属性一样，比较困难的是定义它们的’行为’，以至于能达到我们预期的效果。 作为一名Wordpress主题开发者，AngularJS中的指令给我的第一印象就是与主题模板里面的模板标记特别相似。 从字面意思上可以理解，“模板标记”的使用场景是，在你的博客需要显示一些动态信息时，或者是在定制你的主题的时候，其所提供的这些工具，会让你感到非常的独特和有趣。 也就是说，我们使用模板标记是为了节省时间，举个例子来说，我们经常在同样的页面使用get_header()，get_footer(), get_sidebar()这些Wordpress内置的一些方法。 在这篇教程中，我会向你展示我是如何编写一个名为的自定义指令的。让它像Wordpress中的get_search_form()一样工作。结合WP API，我们可以在刚才的单页应用的例子中，搜索一些结果。就像下图一样： ###0.现在让我们开始吧！ 最佳实践你应该给你自定义的指令附上一些可读性指令，就像这样“”。为了让代码更加整洁和简短，我并没有添加前缀。 我们可以像如下代码一样编写我们的自定义指令 angular.module('app', ['ngRoute', 'ngSanitize'])// ….directive('searchForm', function() { return { restrict: 'EA', template: 'Search Keyword: &lt;input type=&quot;text&quot; name=&quot;s&quot; ng-model=&quot;filter.s&quot; ng-change=&quot;search()&quot;&gt;', };}); See the Pen wadrKP by WangWenyu (@Jacobwang) on CodePen. 可能你已经注意到了，指令的名字”searchForm”是使用的驼峰命名法，当AngularJS在DOM中检测到这个标签时，AngularJS会将自动转换成searchForm。然后去匹配相对应的方法去执行。这样的行为被称为‘统一化’。你可以在这个文档中查看相关的解释 ###1.1 标签或属性？ 默认情况下，自定义指令可以向HTML标签或者属性使用。如果你也喜欢像类名一样的使用它。你需要改变restrict属性值，将它修改成‘EAC’，也就是在之前的“EA”后添加“C”（E指的是元素标记，A指的是属性） ###1.2一个简单搜索表单 一般来说，Wordpress中搜索表单看起来像这样：（通过get_search_form()这个方法生成的） &lt;form role=&quot;search&quot; method=&quot;get&quot; class=&quot;search-form&quot; action=&quot;http://localhost/jsonapi/&quot;&gt; &lt;label&gt; &lt;span class=&quot;screen-reader-text&quot;&gt;Search for:&lt;/span&gt; &lt;input type=&quot;search&quot; class=&quot;search-field&quot; placeholder=&quot;Search …&quot; value=&quot;&quot; name=&quot;s&quot; title=&quot;Search for:&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; class=&quot;search-submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; See the Pen EjmwKq by WangWenyu (@Jacobwang) on CodePen. 因为在模板中需要使用到searchForm指令，为了使代码看起来干净整洁，我移除了submit按钮。仅仅留下了文本输入框。 ###1.3使用ng-model进行数据绑定 使用了ng-model 之后的数据值可能会让你感到奇怪，请注意我使用了过滤器.s，这是我故意的，为了看起来像自带s过滤属性。在$scope中添加这个过滤对象，随后，AngularJS可以监听到值的改变。 ###2.给自定义指令添加controller属性 angular.module('app', ['ngRoute', 'ngSanitize'])// ….directive('searchForm', function() { return { restrict: 'EA', template: 'Search Keyword: &lt;input type=&quot;text&quot; name=&quot;s&quot; ng-model=&quot;filter.s&quot;&gt;', controller: function ( $scope, $http ) { $scope.filter = { s: '' }; $scope.search = function() { $http.get('wp-json/posts/?filter[s]=' + $scope.filter.s).success(function(res){ $scope.posts = res; }); }; } };}); See the Pen NqjarY by WangWenyu (@Jacobwang) on CodePen. ###2.1在$scope中添加filter属性 在控制器中，我们创建search表单之前，我在$scope中添加了一个filter属性，这个属性包含s属性，是给空字符串赋默认值用的。 ###2.2使用$http方法获取搜索的结果 在search方法中，我们依旧使用$http方法与JSON API建立连接。这时，我们需要添加一个额外的参数filter，这个filter参数的作用是对请求到的数据进行一次过滤返回。就像在WP_Query使用query变量一样。在我们添加过这些参数字符串后，请求地址应该是这个样子的： wp-json/posts/?filter[s]=’ + $scope.filter.s. ###3.用户改变输入框的值后进行查询 ###3.1使用内置的ng-change指令 我们该如何不停地切换search方法？你一定会这样想：我能不能像Javascript一样使用onchange事件？答案是肯定的。让我们在input中添加ng-change指令，然后设置其value为search()。现在无论input内的值怎样改变，AngularJS都可以通过JSON API来获取搜索之后的结果 angular.module('app', ['ngRoute', 'ngSanitize'])// ….directive('searchForm', function() { return { restrict: 'EA', template: 'Search Keyword: &lt;input type=&quot;text&quot; name=&quot;s&quot; ng-model=&quot;filter.s&quot; ng-change=&quot;search()&quot;&gt;', controller: function ( $scope, $http ) { $scope.filter = { s: '' }; $scope.search = function() { $http.get('wp-json/posts/?filter[s]=' + $scope.filter.s).success(function(res){ $scope.posts = res; }); }; } };}); See the Pen gpWXrB by WangWenyu (@Jacobwang) on CodePen. 我们在检查”filter.s”长度的时候，要减少对API请求次数，也就是说，查询关键字长度不得少于5. $scope.search = function() { if ( $scope.filter.s.length &gt;= 5 ) { $http.get('wp-json/posts/?filter[s]=' + $scope.filter.s).success(function(res){ $scope.posts = res; }); }}; See the Pen ZGKaOQ by WangWenyu (@Jacobwang) on CodePen. ###3.2. 在你的模板文件中插入标签 &lt;search-form&gt;&lt;/search-form&gt; See the Pen EjmbyZ by WangWenyu (@Jacobwang) on CodePen. 最后一步需要我们做的，就是将我们编写的自定义指令插入到模板之中。我将main.html这个文件的最上方替换成了 &lt;search-form&gt;&lt;/search-form&gt; 或者 &lt;div search-form&gt;&lt;/div&gt; 或者 &lt;div data-search-form&gt;&lt;/div&gt;. ###HTML搜索表单和ng-submit search方法现在应该已经工作了。我再向你展示一个“real”表单。这是刚才那个input例子之后的一个新的例子。我个人比较偏爱一个input的例子。但是更多的例子能让我们更好得掌握AngularJS中的指令的用法。让我们在partials文件夹中创建一个名为search-form.html的新文件。 &lt;form role=&quot;search&quot; ng-submit=&quot;search()&quot;&gt; &lt;label&gt; Search for: &lt;input type=&quot;search&quot; name=&quot;s&quot; ng-model=&quot;filter.s&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Search&quot; /&gt;&lt;/form&gt; See the Pen ZGKaBW by WangWenyu (@Jacobwang) on CodePen. 在自定义指令这个方法中，移除template属性，添加templateUrl属性来设置搜索表单的文件路径 angular.module('app', ['ngRoute', 'ngSanitize'])//….directive('searchForm', function() { return { restrict: 'EA', templateUrl: myLocalized.partials + 'search-form.html', controller: function ( $scope, $http ) { $scope.filter = { s: '' }; $scope.search = function() { $http.get('wp-json/posts/?filter[s]=' + $scope.filter.s).success(function(res){ $scope.posts = res; }); }; } };}); See the Pen qdmVqP by WangWenyu (@Jacobwang) on CodePen. 现在你需要点击submit按钮来获取搜索结果了。就像这样 相关资料 Build custom directives with AngularJS by ng-newsletter Creating Custom AngularJS Directives Part I – The Fundamentalsby Dan Wahlin Angular.js directives – Difference between controller and linkby Jason More 如果你对该教程有任何疑问，请在下方评论，我会抽空回复你们。","link":"/2015/06/08/使用angularjs构建wordpress主题(三)/"},{"title":"使用AngularJS和WP JSON API来构建你的Wordpress主题","text":"第一章：使用AngularJS和WP JSON API来构建你的Wordpress主题 本文翻译:Using AngularJS and JSON API in Your WordPress Theme 之前我在Code School(一个线上编程学习网站)学习AngularJS的经历让我至今难忘，我在工作中用到wordpress也有一段时间了，学习AngularJS和JSON API在一起使用已经在这周成为我的新爱好。 当我开始学习一些新东西的时候，我会先通过google（ps:唉。。天朝用百度吧）搜过一些关键字或者一些关键短语，我搜索到了非常全面的资源，我也准备好深度钻研一下了。为了能更精确的搜索到我想要的结果，我使用了一些长尾关键字缩小了搜索范围。幸运的是，搜索‘WordPress JSON API+AngularJS’这个关键词，我找到了很多优秀的资源，在这里，我将我学到的分享给大家。 在我们开始之前，如果你还不知道AngularJS为何这么流行，为什么Wordpress是一个非常优秀的后台博客程序，你可以参考下这篇文章this slide shared by Eric W. Greene。这是我之前通过搜索得到的结果。 即使你不会使用AngularJS，跟着我的教程，你一样能很顺利的编程。现在，打开你常用的代码编辑器，跟着我一起使用AngularJS制作Wordpress主题吧。 ###0.开始如果你有30分钟空闲，我先建议你观看一个视频，original video from WordPress.tv(ps:要翻墙的，翻墙之后看巨卡！此段请忽略掉)看完之后你可以学到： 在Wordpress中引入scripts的方法 使用JSON REST API (official WP API) 很简短，并且关注在AngularJS 和 JSON API ###1.创建一个新主题（ps:在这我就遵照原文翻译了，就不过多赘述Wordpress主题是怎么制作和编写了。因为hexo那个教程还没写完） 创建一个demo主题，首先这个主题你需要两个文件，分别是index.php和style.css。请确保你的style.css文件写好了正确的Wordpress描述，不然很有可能这个主题不会工作。 接下来粘贴一些简单的HTML代码到你的index.php文件中，就像这样 登录Wordpress后台，应用这个主题 ###2.下载AngularJS 你可能通过之前视频中的方法，使用bower将AngularJS下载到你的主题文件夹中了。你也可以通过在AngularJS官网下载，或者你喜欢nodejs的安装方式，那么在终端敲入npm install angular。 这篇教程主要是简单易行的利用AngularJS开发一个单页应用，这样就肯定免不了AngularJS Route，通过bower或者npm安装起来。bower install angular-route 或者 npm install angular-route. 如果你是通过bower方式安装的，你所下载的AngularJS文件自动的下载到bower_components这个文件夹里。 ###3.引入脚本文件 在你的主题文件夹中创建functions.php文件，我们要编写一些函数钩子来引入脚本 然后一定要记得添加wp_head(); 这段代码在标签中，这样AngularJS就能在头部被引入进来了。 ###4.你好，AngularJS！ 现在我们写一些代码来确保AngularJS能在页面中运行起来吧！ 第二行：ng-app属性，Angular里面的module，可以让AngularJS在页面中跑起来。 第十八行：简单的让一个input文本输入框具有双向绑定功能。ng-model=”name”。 第二十行：通过使用可以通过输入值让页面上的值更新了，双花括号是AngularJS里面的固定的语法。 现在一个简单的AngularJS功能就实现了，如下图所示： ###5.你好，AngularJS路由！ 现在，我们让AngularJS的路由功能实现起来，这可能有点复杂，请跟着我的步骤，一步一步的做下去。 第一步，我们需要覆盖index.php，添加如下代码 第二行：ng-app属性，Angular里面的module，可以让AngularJS在页面中跑起来。 第四行：我添加这个是因为在我这会抛出错误，根据文档，base href非常有必要。在这里我说下，注意这个‘/jsonapi/’我的网站根目录是/jsonapi/，所以这里就写/jsonapi/，你在使用过程中请将/jsonapi/改成你的网站的根目录路径 第十七行：添加ng-view这个属性，是为了让页面能够成功的载入进来。 第二步，创建一个名为partials的文件夹，添加一个名为main.html的新文件，里面随便写点什么，比如：这是一个主文件。文件夹，还有文件名你可以随意命名。 第三步，更新你的functions.php文件。我们要引入自己的scripts.js。使用wp_localized_script这个方法，可以使partials文件夹在script.js文件中生效。 第四步，是时候开始写点JavaScript代码了，如果你更改了app或者其他文件名字，请一同将更改后的文件名更新到scripts.js中。 (ps:补充说下，locationProvider.html5Mode(true);这个是开启html5的history模式的，需要环境支持反向代理，我在使用过程中把这句改成false了，因为我实在配置不好Apache的反向代理。) 如果你正确操作的话，你看到的页面应该是这个样子的 ###6.JSON REST API plugin 前五步都是在说AngularJS带给我们的魔力的，现在我们将使用JSON REST API，请下载JSON REST API并激活它。 使用JSON REST API，你可以像这样请求到数据 [SITE_URL]wp-json/posts 屏幕上会这样显示 ###7.使用AnguJS和JSON API循环显示Wordpress文章 现在我们通过AngularJS来获取最新的文章，让他们显示在主页上，在scripts.js中，我们要告诉Angulajs通过get方式请求“wp-json/posts/”这个地址。我们可以将成功返回的数据命名为posts 然后我们要在main.html文件中更换标记，显示文章列表，使用ng-repeat来循环输出 现在你可以使用API文档提供的键名来输入你想要的数据字段，就像这样 ###8.使用AnguJS和JSON API显示单篇Wordpress文章 新建个文件，命名为contents.html 更新你的scripts.js文件 第十行：小心，这里有“:” 在ID之前，这是说路由名，如果没有“:” 就会被识别成一个ID的字符串。 第二十五行：我们告诉AngularJS通过这个 “wp-json/posts/[ID Param]”请求文章，JSON API 会返回给我们一篇文章。 现在你可以不用通过刷新页面就可以看到一篇文章的内容了，至此，我们完成了一个单页应用。 非常感谢大家花时间在我的这篇教程上，我希望你能像我一样多加学习AngularJS and JSON API 。","link":"/2015/06/07/使用angularjs构建wordpress主题(一)/"},{"title":"OC学习笔记-NSString的常用方法","text":"最近正在学习OC这门语言，有了一些前端的底子之后，学习OC起来也更加方便了一些。 昨晚在完成一项作业的时候，学习了不少东西，在这里对NSString的几个常用方法做一个总结。 1、创建字符串1234NSString *str1 = @\"我在学习OC\"; NSString *str2 = [[NSString alloc] initWithString: @\"我在学习OC\"]; NSString *str3 = [NSString stringWithFormat: @\"我在学习%@\",@\"OC\"]; NSString *str4 = [[NSString alloc] initWithUTF8String:\"我在学习OC\"]; // 由C字符串转换成OC字符串 2、获取字符串长度1NSUInteger length = str.length; 3、获取字符串某个位置的字符1unichar c = [str characterAtIndex:1]; // 索引从0开始 4、截取字符串12NSRang *rang = {1,2}; //location（索引开始的位置）、length（截取的长度）; NSString *subString = [str substringWithRange:rang]; 5、获取子字符串在字符串中的索引位置和长度1NSRange range = [str rangeOfString:subString]; // 如果未找到 返回{-1, 0} 6、判断字符串内容是否相同1BOOL isEqual = [str1 isEqualToString：str2] 7、替换字符串中的子字符串为给定的字符串1NSString * newStr = [str stringByReplacingOccurrencesOfString: @\"a\" withString: @\"b\"]; NSMutableableString1、追加字符串返回新字符串12NSString *str = it NSString *newStr = [str stringByAppendingString: @“heima”]; 2、追加字符串12NSMutableableString *mstr = [[NSMutableableString alloc] init]; [mstr appendString: @“你好”]; 3.在指定的索引位置插入字符串1[mstr insertString: @“itheima” atIndex：2]; 4、删除指定范围的字符串12NSRange range = {3,5}; [mstr deleteCharactersInRange:rang];","link":"/2016/02/19/Objective-C学习/OC学习笔记-NSString的常用方法/"},{"title":"OC学习笔记-NSValue的常用方法","text":"占坑","link":"/2016/02/19/Objective-C学习/OC学习笔记-NSValue的常用方法/"},{"title":"OC学习笔记-prepareForSegue:sender viewController之间数据传递","text":"IOS开发中，storyboard在UI层面起到了很关键的作用，能让应用在多个ViewController之间来回的切换。切换之中，不可避免的就会遇到多个ViewController之间的数据传递，这里，storyboard有一个非常重要的方法：prepareForSegue:sender 首先，我们查阅下官方的文档，官方文档里对prepareForSegue:sender是这样描述的： 不难看出，OC中完整的表达式是 12- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 这个方法包含两个参数 segue 和 sender。 主要解决2个问题： （1） 获取所要跳转到的视图控制器 （ViewController）； （2） 同时，将上一个视图的数据，传递给下一个视图。（比如：获取上一个视图中某一个输入框中用户填写的内容，并传递给下一个视图之中） 我们再来看参数： segue 这个参数包含了三个重要的属性 123@property (nonatomic, readonly) NSString *identifier;//控制器标识符@property (nonatomic, readonly) id sourceViewController;//源控制器，就是从哪里跳转的@property (nonatomic, readonly) id destinationViewController;//目标控制器，就是跳转到哪里 sender是触发这个场景切换的事件源 我们来看具体的代码示例： 首先是控制器视图1的部分 12345678910//// ViewController.h//#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@end 12345678910111213141516171819202122232425262728293031323334353637383940//// ViewController.m//#import \"ViewControllerStep1.h\"#import \"ViewControllerStep2.h\"@interface ViewController ()@property (weak, nonatomic) IBOutlet UITextField *usernameText;@property (weak, nonatomic) IBOutlet UITextField *passwordText;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.}//看这个部分- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{ if ([[segue identifier] isEqualToString:@\"toStep2\"]) {//这里是为了比较是否是切换到这个Segue场景，Segue的identifier一定要填写，不然会报错 NSString * username = self.usernameText.text; ViewControllerStep2 *getAllInfo=[segue destinationViewController];//这一步就是使用属性的方法，给目标场景传值 getAllInfo.name= username;//看step2的头文件 NSLog(@\"%@\",username); }}//结束- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.}@end 接下来是控制器视图2的部分 123456789101112//// ViewControllerStep2.h//#import &lt;UIKit/UIKit.h&gt;@interface ViewControllerStep2 : UIViewController@property(strong,nonatomic)NSString *name;//头文件中我们定义了一个name String，用来为了让源控制器传值@end 1234567891011121314151617181920212223242526272829//// ViewController.m//#import \"ViewControllerStep2.h\"@interface ViewControllerStep2 ()@property (weak, nonatomic) IBOutlet UILabel *userValue;@property (weak, nonatomic) IBOutlet UITextField *userEmailText;@end@implementation ViewControllerStep2- (void)viewDidLoad { [super viewDidLoad]; NSLog(@\"%@\",_name);//输出源目标传递的name值 // Do any additional setup after loading the view, typically from a nib.}- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.}@end 我会在下一篇介绍一下NavigationController中的一些坑","link":"/2016/02/19/Objective-C学习/OC学习笔记-prepareForSegue sender ViewController之间数据传递/"},{"title":"EC2搭建vpn服务器","text":"sudo ssh -i ‘/home/xxx/dev/tools/bin/dev.pem’ ubuntu@54.186.250.161 ssh 用用户名密码登陆sudo passwd rootvi /etc/ssh/sshd_config找到 PasswordAuthentication no，把no改成yes接下来，要重新启动下sshd/sbin/service sshd restart service ssh restart/etc/init.d/ssh restart root登陆，需要设置root登陆 公钥生成私钥：http://www.linuxidc.com/Linux/2012-08/69301.htm http://www.dikant.de/2010/10/08/setting-up-a-vpn-server-on-amazon-ec2/1.使用Putty连接到EC2实例； 2.安装pptp守护：sudo apt-get install pptpd 3.编辑pptp配置文件：sudo vim /etc/pptpd.conf找到localip和remoteip,去掉注释即可localip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245 4.使用Google Public DNS：sudo vim /etc/ppp/pptpd-options找到包含ms-dns，去掉注释，并修改如下：ms-dns 8.8.8.8ms-dns 8.8.4.4 5.配置访问VPN的用户名和密码sudo vim /etc/ppp/chap-secrets按一行四列添加账号、服务器名、密码和IP限制。服务器名（默认 写pptpd 即可，务必与 pptpd-options 文件的name一行一样）。如创建一个名为user，密码为userpasswd，不限制登录IP的VPN账号：user pptpd userpasswd * 6.重启服务：sudo /etc/init.d/pptpd restart 7.已经可以连接到pptp，下面配置数据转发。编辑/etc/sysctl.confsudo vim /etc/sysctl.conf将下面一行的注释去掉net.ipv4.ip_forward=1重新加载sudo sysctl -p 8.网络地址转换sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE确保服务器重启后服务可用：sudo vim /etc/rc.local在exit 0上面加一行iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 9.重启服务sudo /etc/init.d/pptpd restart #google computer engine dabian OS上面的步骤，完了以后，建立不起来vpn，原因不详细。 ssh ubuntu@54.208.20.229 连接上自己的vpn后，无法用ssh登陆自己的服务器。原因不详。。。 脚本如下：wget https://raw.githubusercontent.com/danhantao/ec2-vpn/master/ec2-vpn.sh sudo su export VPN_USERNAME=dev VPN_PASSWORD=dev VPN_USERNAME为vpn用户名 VPN_PASSWORD为vpn密码 sh ec2-vpn.sh","link":"/2016/07/12/EC2搭建vpn服务器/EC2搭建vpn服务器/"},{"title":"","text":"网上很多都说通过源码编译安装比yum安装性能提升很多，但这里只提供yum安装方式，源码编译安装过程遇到的问题繁琐，本人经验尚浅，就不在这提供了，敬请谅解 安装PHP7.3据说7.3比7.0的性能提升20% 添加php最新的源12sudo yum -y install http://rpms.remirepo.net/enterprise/remi-release-7.rpm sudo yum -y install epel-release yum-utils 禁用之前的源12sudo yum-config-manager --disable remi-php54 //这里根据你自己的版本来sudo yum-config-manager --enable remi-php73 安装php以及需要的插件1sudo yum -y install php php-cli php-fpm php-mysqlnd php-zip php-devel php-gd php-mcrypt php-mbstring php-curl php-xml php-pear php-bcmath php-json 检查版本1$ php -v 如何安装扩展1sudo yum install php-&lt;entension-name&gt; 查看php.ini位置1php -i | grep &quot;php.ini&quot; 默认安装完成之后，php.ini文件位置在/etc/php.ini 通过yum安装完成之后，php-fpm服务应该是加入启动项之中的，可以通过命令来检查是否开机启动 1systemctl is-enabled php-fpm 安装MYSQLyum上是没有mysql源的，需要自行配置 1wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 安装源信息1rpm -ivh mysql57-community-release-el7-9.noarch.rpm 安装mysql1yum install mysql-server 获取临时访问密码mysql5.7开始，新安装的数据库会临时给一个密码 1grep &apos;temporary password&apos; /var/log/mysqld.log 登录1mysql -u root -p你刚刚获取的临时密码 修改密码1set password=password(&quot;yourpassword&quot;); 设置安全选项1mysql_secure_installation 配置文件1/etc/my.cnf 相关操作命令1systemctl start|stop|restart|status|enable mysql 安装nginx安装nginx源1rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx1yum install -y nginx 查找nginx123whereis nginxnginx: /usr/bin/nginx /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz 以下是Nginx的默认路径： (1) Nginx配置路径：/etc/nginx/ (2) PID目录：/var/run/nginx.pid (3) 错误日志：/var/log/nginx/error.log (4) 访问日志：/var/log/nginx/access.log (5) 默认站点目录：/usr/share/nginx/html 相关操作命令1systemctl start|stop|restart|status|enable nginx","link":"/2019/03/11/CentOS 7.x 搭建LNMP环境(长期更新中)/CentOS 7.x 搭建LNMP环境(长期更新中)/"},{"title":"React 无状态组件 与 高阶组件","text":"react 无状态组件 与 高阶组件 高阶组件通过函数和闭包,改变已有组件的行为,本质上就是 Decorator 模式在React的一种实现。 定义 123456789101112131415import { Component } from \"React\" ;export const Enhance = (ComposedComponent) =&gt; { return class extends Component { constructor() { this.state = { data: null }; } componentDidMount() { this.setState({ data: 'Hello' }); } render() { return &lt;ComposedComponent {...this.props} data={this.state.data} /&gt;; } }} Enhance 是一个方法，当传入一个 Component（ComposedComponent） 的时候，它将自动为该 Component 进行扩展并返回新的类定义。Enhance 中就返回了一个扩展的 Component 类，为构造函数中添加了 state，也在 React 生命周期函数 componentDidMount中添加了处理逻辑，而 render 方法则使用了传入的参数，完成了渲染。 用法 1234567891011import { Component } from \"React\";import { Enhance } from \"./Enhance\";class MyComponent = class extends Component { render() { if (!this.props.data) return &lt;div&gt;Waiting...&lt;/div&gt;; return &lt;div&gt;{this.data}&lt;/div&gt;; }}export default Enhance(MyComponent); // Enhanced component` 另一个例子 1234567891011121314151617181920212223242526272829303132function connectPromise({promiseLoader, mapResultToProps}) { return Comp=&gt; { return class AsyncComponent extends Component { constructor(props) { super(); this.state = { result: undefined } } componentDidMount() { promiseLoader() .then(result=&gt; this.setState({result})) } render() { return ( &lt;Comp {...mapResultToProps(props)} {...this.props}/&gt; ) } } }}const UserList = connectPromise({ promiseLoader: loadUsers, mapResultToProps: result=&gt; ({list: result.userList})})(List); //List can be a pure componentconst BookList = connectPromise({ promiseLoader: loadBooks, mapResultToProps: result=&gt; ({list: result.bookList})})(List); 无状态组件无状态组件不支持 ref当无状态组件需要使用到生命周期时，可使用高阶组件包装 1234function HelloComponent(props, /* context */) { return &lt;div&gt;Hello {props.name}&lt;/div&gt;}ReactDOM.render(&lt;HelloComponent name=\"Sebastian\" /&gt;, mountNode) 1234567891011121314151617function Input({ label, name, value, ...props }, { defaultTheme }) { const { theme, autoFocus, ...rootProps } = props return ( &lt;label htmlFor={name} children={label || defaultLabel} {...rootProps} &gt; &lt;input name={name} type=\"text\" value={value || ''} theme={theme || defaultTheme} {...props} /&gt; )}Input.contextTypes = {defaultTheme: React.PropTypes.object};","link":"/2017/02/20/React 无状态组件 与 高阶组件/React 无状态组件 与 高阶组件/"},{"title":"php 获取系统信息","text":"我在开发cms的过程中，在首页想获取一堆系统信息，这样显得高大上，在查找了一番资料之后，我将它封装成了一个方法 12345678910111213141516171819202122232425public function get_sys_info(){ $sys_info['os'] = PHP_OS; $sys_info['zlib'] = function_exists('gzclose') ? 'YES' : 'NO';//zlib $sys_info['safe_mode'] = (boolean) ini_get('safe_mode') ? 'YES' : 'NO';//safe_mode = Off $sys_info['timezone'] = function_exists(\"date_default_timezone_get\") ? date_default_timezone_get() : \"no_timezone\"; $sys_info['curl'] = function_exists('curl_init') ? 'YES' : 'NO'; $sys_info['web_server'] = $_SERVER['SERVER_SOFTWARE']; $sys_info['phpv'] = phpversion(); $sys_info['ip'] = GetHostByName($_SERVER['SERVER_NAME']); $sys_info['fileupload'] = @ini_get('file_uploads') ? ini_get('upload_max_filesize') :'unknown'; $sys_info['max_ex_time'] = @ini_get(\"max_execution_time\").'s'; //脚本最大执行时间 $sys_info['set_time_limit'] = function_exists(\"set_time_limit\") ? true : false; $sys_info['domain'] = $_SERVER['HTTP_HOST']; $sys_info['memory_limit'] = ini_get('memory_limit'); $sys_info['version'] = file_get_contents('./Application/Admin/Conf/version.txt'); $mysqlinfo = M()-&gt;query(\"SELECT VERSION() as version\"); $sys_info['mysql_version'] = $mysqlinfo['version']; if(function_exists(\"gd_info\")){ $gd = gd_info(); $sys_info['gdinfo'] = $gd['GD Version']; }else { $sys_info['gdinfo'] = \"未知\"; } return $sys_info; } 将这个方法放到Controller层中就可以，在输出的时候注册$sys_info到前台就可以输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;table class=\"table table-bordered\"&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt; 服务器操作系统： &lt;/td&gt; &lt;td&gt; {$sys_info.os} &lt;/td&gt; &lt;td&gt; 服务器域名/IP： &lt;/td&gt; &lt;td&gt; {$sys_info.domain} [ {$sys_info.ip} ] &lt;/td&gt; &lt;td&gt; 服务器环境： &lt;/td&gt; &lt;td&gt; {$sys_info.web_server} &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; PHP 版本： &lt;/td&gt; &lt;td&gt; {$sys_info.phpv} &lt;/td&gt; &lt;td&gt; Mysql 版本： &lt;/td&gt; &lt;td&gt; {$sys_info.mysql_version} &lt;/td&gt; &lt;td&gt; GD 版本 &lt;/td&gt; &lt;td&gt; {$sys_info.gdinfo} &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 文件上传限制： &lt;/td&gt; &lt;td&gt; {$sys_info.fileupload} &lt;/td&gt; &lt;td&gt; 最大占用内存： &lt;/td&gt; &lt;td&gt; {$sys_info.memory_limit} &lt;/td&gt; &lt;td&gt; 最大执行时间： &lt;/td&gt; &lt;td&gt; {$sys_info.max_ex_time} &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 安全模式： &lt;/td&gt; &lt;td&gt; {$sys_info.safe_mode} &lt;/td&gt; &lt;td&gt; Zlib支持： &lt;/td&gt; &lt;td&gt; {$sys_info.zlib} &lt;/td&gt; &lt;td&gt; Curl支持： &lt;/td&gt; &lt;td&gt; {$sys_info.curl} &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;","link":"/2016/08/01/php 获取系统信息/php 获取系统信息/"},{"title":"Quiver快速入门","text":"Quiver 是一个程序员专用的记事本应用，可轻松混合文本、代码、Markdown、LaTeX 到一个记事本中。提供强大的代码编辑功能，以及对 Markdown 和 LaTeX 的编辑和即时预览，提供全文搜索功能。 本文来自https://github.com/HappenApps/Quiver/wiki/Quiver%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8 1 - 开始使用欢迎使用 Quiver！本教程将帮助您入门。 如果你想立即开始使用 Quiver，只用记住一件事： Quiver 的笔记是由单元格组成。 单元格可以是一段文本，代码，Markdown，或者LaTeX。一个笔记中可以混排不同类型的单元格，甚至可以给不同的代码单元格设置不同的语言。 新建一个笔记，开始键入你想写的内容。按”shift + 返回”(⇧⏎) 创建一个新的单元格，使用退格键合并单元格。只要知道这些你就可以开始使用 Quiver 了。 但如果你想要了解更多，请继续阅读。 2 - 单元格类型目前支持五种单元格类型: 文本单元格：支持富文本编辑，图像和链接。 代码单元格：使用 ACE 代码编辑器，语法高亮显示支持 120+ 语言、 20 + 主题、 支持自动缩进、 代码自动补全，功能多多。 Markdown 单元格：支持自定义 CSS，即时预览。 LaTeX 单元格： 使用 MathJax 来排版笔记中的数学公式。 图表单元格：使用纯文本创建序列图和流程图。 文本单元格 你可以使用工具栏按钮或键盘快捷方式更改文本格式。在”格式”菜单下可以找到所有格式设置选项和键盘快捷方式。 代码单元格这是一个代码单元格设置为 JavaScript 模式: 1234void hello(){ console.log(\"Hello World!\");} 这是一个代码单元格设置为 CoffeeScript 模式: 1hello = -&gt; console.log 'Hello World!' 代码单元格支持 120 + 语言的语法高亮、 20 + 主题、 自动缩进，代码折叠，多个游标和选择、 代码自动补全、tab 触发，Vim/Emacs 键绑定等。在 Ace 代码编辑器的网站 http://ace.c9.io 上，你可以读到更多 Ace 代码编辑器的功能。 Markdown 单元格Markdown 单元格支持标准 Markdown 语法以及 GitHub Flavored Markdown (GFM)。 基本格式123456789101112# 标题 1## 标题 2### 标题 3#### 标题 4##### 标题 5###### 标题 6---*斜体*, **粗体**, ~~划除~~`行内代码` 列表1234561. 第一个有序的列表项2. 另一个列表项 * 无序的子列表1. 实际数字不重要 1. 有序的子列表4. 另一个列表项 引用1&gt; 和平不能靠武力; 它只可以通过理解来实现。 链接12[行内链接](https://www.google.com)http://example.com 你可以创建链接到另一个笔记：(“笔记”菜单 -&gt; 复制笔记链接 -&gt; 粘贴)1[01 - Getting Started](quiver-note-url/D2A1CC36-CC97-4701-A895-EFC98EF47026) 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | GFM 任务列表12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed 行内 LaTeX您可以在 Markdown 单元格中使用行内 LaTeX，例如，$x^2$。 LaTeX 单元格使用 LaTeX 单元格可以很容易地排版数学公式。例如， 123456\\begin{align} \\nabla \\times \\vec{\\mathbf{B}} -\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} &amp; = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\\\ \\nabla \\cdot \\vec{\\mathbf{E}} &amp; = 4 \\pi \\rho \\\\ \\nabla \\times \\vec{\\mathbf{E}}\\, +\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} &amp; = \\vec{\\mathbf{0}} \\\\ \\nabla \\cdot \\vec{\\mathbf{B}} &amp; = 0\\end{align} 预览如下： 也可以在行内使用 LaTeX，例如，$x^2$。 您还可以在设置中添加自定义宏。添加的自定义宏可以在所有的 LaTeX 单元格中使用。 图表单元格使用图标单元格可以很方便地创建序列图和流程图。 请参照这里的语法： 序列图: http://bramp.github.io/js-sequence-diagrams/ 流程图: http://flowchart.js.org/ 序列图示例: 12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 预览如下： 流程图示例: 1234567891011st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yesor No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 预览如下： 3 - 单元格操作单元格操作很容易上手，但其实功能强大。 其中最重要的一个操作你已经学会了：按”shift + 返回”(⇧⏎) 来创建一个新的单元格。默认情况下新建的单元格是一个文本单元格，但你可以轻松地将其转换为其它类型的单元格。 转换单元格类型有好几种方法：你可以使用工具栏上的下拉菜单，或者键盘快捷方式 (⌥⌘1 转换为文本单元格，⌥⌘2 转换为代码单元格，⌥⌘3 转换为 Markdown 单元格，⌥⌘4 转换为 LaTeX 单元格，⌥⌘5 转换为图表单元格)。这些快捷方式可以在“单元格”菜单下找到。 另一个重要的操作是如何合并两个单元格。只需将光标放在第二个单元格的开头，然后按回退键。请注意不同类型的单元格不能合并。 有时候你可能想在当前光标位置添加一个新的单元格。你可以用“单元格”菜单下的 “New Cell At Cursor” (⇧⌘I) 菜单项实现。 你还可以剪切、复制或粘贴单元格，拆分单元格，向上或向下移动单元格。所有这些单元格操作和其相应的键盘快捷方式可以在“单元格”菜单下找到。 4 - 图像、 文件和链接你可以拖拽或粘贴图像到文本单元格中。你也可以使用工具栏中的“插入图像”按钮 。 插入的图像自动复制到当前笔记的资源文件夹中，因此即使原始图像被删除，笔记中的图像也照样可以使用。 如果将一个文件 (例如，PDF、 zip、 源文件) 拖拽到文本单元格中，你可以选择将它复制到资源文件夹，或者保存为链接。您也可以使用工具栏中的“附加文件”按钮。 如果粘贴的文本中有 URL，Quiver 会自动将其转换为链接，比如 http://www.apple.com。 另一个有用的功能是笔记链接。您可以使用“笔记”菜单下的菜单项”复制笔记链接”(⌃⌥⌘C)来复制当前笔记的链接，例如： 02 - Cell Types 03 - Cell Operations 这样你可以很方便地交叉引用你的笔记。不同笔记本中的笔记也可以相互链接。 笔记链接在 Markdown 单元格中也可以使用。在“笔记”菜单下使用菜单项“复制笔记链接”(⌃⌥⌘C)，然后粘贴到 Markdown 单元格。例如： 1[02 - Cell Types](quiver-note-url/9686AA1A-A5E9-41FF-9260-C3E0D0E9D4CB) 它在预览或演示模式中会变成笔记链接。 5 - 预览和演示模式即时预览Quiver 支持 Markdown 和 LaTeX 的即时预览。你可以切换到同时显示编辑器和预览的双栏模式 (⌘6)。 你也可以双击列表中的笔记在新窗口打开，然后切换到双栏模式。例如： 当您在编辑器中进行更改时，预览会实时更新。 默认情况下，编辑器和预览之间会同步滚动。但您可以在视图菜单中关闭此功能。 演示模式Quiver 还支持全屏幕演示模式。您可以从“笔记”菜单中选择“启动演示”(⌃⌥⌘P)，或单击笔记右下角的“演示”按钮。 演示模式非常适合教室使用、 团队会议、 演示或者自己复习笔记。 在演示模式中，你可以使用左/右箭头键来移动到列表中的上个/下个笔记。 6 - 全文搜索笔记再好，不能快速找到也没用。Quiver 的全文搜索是基于苹果操作系统中 Spotlight 使用的底层工具：Search Kit。因此 Quiver 可以瞬间搜索数以千计的笔记。 若要搜索所有的笔记，请单击右上角的搜索按钮。你可以通过关键字、 标题或 #标签 搜索。 你也可以在一个笔记本中搜索。首先打开笔记本，在列表底部的搜索框中输入关键字或 #标签。这也是全文搜索，不过只显示当前笔记本中的搜索结果。 如果你想在一个笔记中查找关键词，请使用 ⌘F。你会看到一个查找工具栏： 使用 ⌘G (或回车键) 跳转到下一个搜索结果。用 ⇧⌘G （或 shift + 回车）向上查找。 查找工具栏在编辑器和预览中都可以使用。 7 - 标签Quiver 支持给笔记加标签。这是又一种整理笔记的方式。 你可以按标签分类来浏览笔记： 如果你从列表中同时选择多个笔记，你可以同时给他们添加或删除标签。 8 - 云同步Quiver 支持使用任意基于文件的云盘同步，比如 Dropbox，iCloud Drive，Google Drive。 要使用云同步，在设置中打开同步页： 将你的 Quiver 库文件转移到 Dropbox 或其他云盘，然后在另一台电脑上打开库文件。这样两台电脑上的笔记会随时同步。 9 - 团队协作Quiver 支持好几种团队协作的方法。 共享笔记本共享笔记本是保存在云盘上的一个笔记本。任何基于文件的云盘都可以，比如 Dropbox，iCloud Drive，Google Drive。你可以创建一个新的共享笔记本，或者将一个本地笔记本移到云盘上转换成共享笔记本。另一个团队成员可以在另一台电脑上打开共享笔记本，进行编辑。共享笔记本中的笔记会自动同步。这是一个很好的创建团队共享知识库的方法。 多个用户可以同时对同一个共享笔记本进行操作，比如添加或删除笔记，添加或删除标签。这些操作会自动同步。但是，请注意如果两个团队成员同时修改同一个笔记，Quiver 不会自动解决冲突，而是提醒其中一方笔记已被修改，需要刷新。 版本控制如果你使用版本控制系统来管理你的代码和文档，建议你也用版本控制系统 （Git， SVN）来管理 Quiver 的笔记。因为 Quiver 的笔记只是普通的 JSON 文本文件，你可以作为文本文件将它们提交到存储库中。 你可以将整个 Quiver 库文件放到版本控制中，或者只放几个笔记本。用版本控制系统管理 Quiver 笔记的一个好处是：如果两个用户同时编辑一个笔记，用版本控制系统可以很方便地解决合并冲突。 10 - 备份和恢复对于那些不使用云同步或版本控制的用户，还有一种方式可以保管好您的笔记。 若要备份整个库文件，请在设置中打开备份设置页： 选择“备份”来备份您的所有笔记。如果你想要从以前的备份中还原您的所有笔记，请选择“从备份恢复” 然后选择以前的备份。 11 - 导入与导出Quiver 不会将你的笔记锁住。 Quiver 的笔记本和笔记都保存为普通的 JSON 文本文件。文件格式在此有详细的说明：https://github.com/HappenApps/Quiver/wiki/Quiver-Data-Format。 因此你可以放心，你的笔记永远不会无法读取。而且，Quiver 也很容易与你使用的其它工具集成。 Quiver 自带的导出器支持 HTML、 PDF 和 Markdown。你可以导出整个 Quiver 的笔记本为相互链接的 HTML 网页。 导出为 Markdown 时，代码单元格会自动转换为 Markdown 内嵌代码块。这样你可以很方便地将导出的 Markdown 文件上传到 GitHub 或其它使用 Markdown 的平台。 如果你有特殊的导入或导出的需要，你可以很容易地写一个脚本，读取 Quiver 的笔记格式，然后导出成你想要的格式。自定义脚本对于编写编程相关的书籍或教程的用户尤其有用。 几个示例脚本可以在这里找到: https://github.com/HappenApps/Quiver/wiki/Export-Scripts。 12 - 设置在常规设置页，您可以更改默认的笔记列表排序、 默认单元格类型等。 在主题设置页，您可以管理界面的主题。Quiver 附带了几个设计精美的主题，包括一个浅色主题和一个深色主题。你也可以自己设计主题。 在单元格设置页，您可以显示/隐藏行号，启用代码自动补全、 更改键绑定，创建整个应用程序范围的 LaTeX 自定义宏等。 在样式设置页，您可以给编辑器、 预览、 演示、 导出的 HTML 或 PDF 设置自定义样式。支持的所有标准的 CSS 规则，如字体大小、 文本颜色、 背景颜色等。 在快捷方式设置页，您可以设置几个系统键盘快捷方式: 将 Quiver 窗口移前、 创建新笔记，和搜索笔记。 同步设置页和备份设置页前面已讲过了。 在高级设置页，您可以将您的设置和自定义 CSS 导出成一个 JSON 文件。这样你可以轻松地在另一台电脑上加载同样的设置。","link":"/2016/02/10/Quiver快速入门/Quiver快速入门/"},{"title":"jquery validate.js 内置及自定义验证规则","text":"内置的验证规则required:true 必输字段remote:”check.php” 使用ajax方法调用check.php验证输入值email:true 必须输入正确格式的电子邮件url:true 必须输入正确格式的网址date:true 必须输入正确格式的日期dateISO:true 必须输入正确格式的日期(ISO)，例如：2010-01-01，2010/01/01 只验证格式，不验证有效性number:true 必须输入合法的数字(负数，小数)digits:true 必须输入整数creditcard: 必须输入合法的信用卡号equalTo:”#field” 输入值必须和#field相同accept: “gif|png|jpg” 输入拥有合法后缀名的字符串（上传文件的后缀），多个后缀之间用’|’隔开maxlength:5 输入长度最多是5的字符串(汉字算一个字符)minlength:10 输入长度最小是10的字符串(汉字算一个字符)rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串”)(汉字算一个字符)range:[5,10] 输入值必须介于 5 和 10 之间max:5 输入值不能大于5min:10 输入值不能小于10 自定义验证规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//判断两个值是否相等 jQuery.validator.addMethod(\"notEqualTo\", function (value, element, param) { return value != $(param).val(); }, $.validator.format(\"两次输入不能相同!\")); //只能输入数字 jQuery.validator.addMethod(\"isNum\", function (value, element) { var RegExp = /^\\d+$/; return RegExp.test(value); }, $.validator.format(\"只能为数字!\")); //规则名：buga,value检测对像的值 $.validator.addMethod(\"buga\", function (value) { return value == \"buga\"; }, 'Please enter \"buga\"!'); //规则名：chinese，value检测对像的值，element检测的对像 $.validator.addMethod(\"chinese\", function (value, element) { var chinese = /^[\\u4e00-\\u9fa5]+$/; return (chinese.test(value)) || this.optional(element); }, \"只能输入中文\"); //规则名：byteRangeLength，value检测对像的值，element检测的对像,param参数 jQuery.validator.addMethod(\"byteRangeLength\", function (value, element, param) { var length = value.length; for (var i = 0; i &lt; value.length; i++) { if (value.charCodeAt(i) &gt; 127) { length++; } } return this.optional(element) || (length &gt;= param[0] &amp;&amp; length &lt;= param[1]); }, $.validator.format(\"请确保输入的值在{0}-{1}个字节之间(一个中文字算2个字节)\")); // 联系电话(手机/电话皆可)验证 jQuery.validator.addMethod(\"isPhone\", function (value, element) { var length = value.length; var mobile = /^(((13[0-9]{1})|(15[0-9]{1}))+\\d{8})$/; var tel = /^\\d{3,4}-?\\d{7,9}$/; return this.optional(element) || (tel.test(value) || mobile.test(value)); }, \"请正确填写您的联系电话\"); // 邮政编码验证 jQuery.validator.addMethod(\"isZipCode\", function (value, element) { var tel = /^[0-9]{6}$/; return this.optional(element) || (tel.test(value)); }, \"请正确填写您的邮政编码\"); // 字符验证 jQuery.validator.addMethod(\"string\", function (value, element) { return this.optional(element) || /^[\\u0391-\\uFFE5\\w]+$/.test(value); }, \"不允许包含特殊符号!\"); // 必须以特定字符串开头验证 jQuery.validator.addMethod(\"begin\", function (value, element, param) { var begin = new RegExp(\"^\" + param); return this.optional(element) || (begin.test(value)); }, $.validator.format(\"必须以 {0} 开头!\")); // 验证两次输入值是否不相同 jQuery.validator.addMethod(\"notEqualTo\", function (value, element, param) { return value != $(param).val(); }, $.validator.format(\"两次输入不能相同!\")); // 验证值不允许与特定值等于 jQuery.validator.addMethod(\"notEqual\", function (value, element, param) { return value != param; }, $.validator.format(\"输入值不允许为{0}!\")); // 验证值必须大于特定值(不能等于) jQuery.validator.addMethod(\"gt\", function (value, element, param) { return value &gt; param; }, $.validator.format(\"输入值必须大于{0}!\")); // 验证值小数位数不能超过两位 jQuery.validator.addMethod(\"decimal\", function (value, element) { var decimal = /^-?\\d+(\\.\\d{1,2})?$/; return this.optional(element) || (decimal.test(value)); }, $.validator.format(\"小数位数不能超过两位!\")); //字母数字 jQuery.validator.addMethod(\"alnum\", function (value, element) { return this.optional(element) || /^[a-zA-Z0-9]+$/.test(value); }, \"只能包括英文字母和数字\"); // 汉字 jQuery.validator.addMethod(\"chcharacter\", function (value, element) { var tel = /^[\\u4e00-\\u9fa5]+$/; return this.optional(element) || (tel.test(value)); }, \"请输入汉字\"); // 身份证号码验证（加强验证） jQuery.validator.addMethod(\"isIdCardNo\", function (value, element) { return this.optional(element) || /^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$/.test(value) || /^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d{4})|\\d{3}[A-Z])$/.test(value); }, \"请正确输入您的身份证号码\"); // 手机号码验证 jQuery.validator.addMethod(\"isMobile\", function (value, element) { var length = value.length; var mobile = /^(((13[0-9]{1})|(15[0-9]{1})|(17[0-9]{1})|(18[0-9]{1})|(14[0-9]{1}))+\\d{8})$/; return this.optional(element) || (length == 11 &amp;&amp; mobile.test(value));}, \"请正确填写您的手机号码\"); // 电话号码验证 jQuery.validator.addMethod(\"isTel\", function (value, element) { var tel = /^\\d{3,4}-?\\d{7,9}$/; //电话号码格式010-12345678 return this.optional(element) || (tel.test(value)); }, \"请正确填写您的电话号码\"); 调用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//页面加载时调用 $(function () { $('#cerform').validate({ rules: { txtUserName: { required: true, maxlength: 8, minlength: 4 }, txtUserCardID: { required: true, maxlength: 18, minlength: 18, isIdCardNo: \"#txtUserCardID\" }, txtUserPwd: { required: true, maxlength: 18, minlength: 6, notEqualTo: \"#txtUserPwd\" }, txtRUserPwd: { required: true, equalTo: \"#txtUserPwd\" }, txtAddress: { required: true, maxlength: 50 }, txtAreaContent: { required: true, maxlength: 300 }, txtUrl: { required: true, url: true }, txtPhone: { required: true, minlength: 7, maxlength: 13, isTell: true, isMobile: \"#txtPhone\" }, txtZipCode: { required: true, minlength: 6, maxlength: 6, isNum: true }, txtEmail: { required: true, email: true, maxlength: 40 } }, messages: { txtUserName: { required: \"用户名不能为空！\", maxlength: \"最长为18个字符！\", minlength: \"最短为4个字符！\", remote: \"该用户名已被占用！\" }, txtUserCardID: { required: \"身份证不能为空！\", maxlength: \"身份证为18个字符！\", minlength: \"身份证为18个字符！\" }, txtUserPwd: { required: \"密码不能为空！\", maxlength: \"最长为18个字符！\", minlength: \"最短为6个字符！\", notEqualTo: \"用户名和密码不能相同！\" }, txtRUserPwd: { required: \"密码不能为空！\", equalTo: \"两次输入密码不相同！\" }, txtAddress: { required: \"地址不能为空！\", maxlength: \"最长50个字符！\" }, txtAreaContent: { required: \"不能为空！\", maxlength: \"最长300个字符！\" }, txtUrl: { required: \"网址不能为空！\", url: \"请填写正确的网址！\" }, txtPhone: { required: \"电话不能为空！\", minlength: \"最少7个数字！\", maxlength: \"最长13个数字！\", isTell: \"电话格式不正确！\" }, txtZipCode: { required: \"邮编不能为空！\", minlength: \"邮编为6个数字！\", maxlength: \"邮编为6个数字！\", isNum: \"请输入数字！\" }, txtEmail: { required: \"邮箱不能为空！\", email: \"邮箱格式不正确！\", maxlength: \"最长40个字符！\" } }, errorPlacement: function (error, element) { error.appendTo(element.parent()); }, submitHandler: function (form) { form.submit(); }, errorClass: \"error\", focusCleanup: true, //被验证的元素获得焦点时移除错误信息 success: function (label) { label.html(\"&lt;span style=\\\"color:green\\\"&gt;填写正确！&lt;/span&gt;\").addClass(\"success\"); } }); //所有使用“.ipt_txt”样式的文本框加上效果，获得焦点文本框变成淡黄色 $(\".ipt_txt\").focus(function () { www.2cto.com $(this).css(\"background-color\", \"#FFFFCC\").blur(function () { $(this).css(\"background-color\", \"#FBFBFB\"); }); }); });","link":"/2016/07/23/jquery validate.js 内置及自定义验证规则/jquery validate.js 内置及自定义验证规则/"},{"title":"ECMAScript2015学习笔记-字符串的扩展","text":"##Unicode 在ES6中，字符串部分增加了对unicode的支持，这块对我来说平时难以涉及，就此略过 ##新增方法 ###includes() startsWith() endsWith() 与indexOf方法类似，确定一个字符串是否包含在另一个字符串中。 includes():返回布尔值，表示是否找到了参数字符串startsWith():返回布尔值，表示参数字符串是否在源字符串头部endsWith():返回布尔值，表示参数字符串是否在源字符串尾部 1234var str = \"Hello World!\";str.startsWith(\"Hello\");//truestr.endsWith(\"!\");//truestr.includes(\"0\")//true 三个方法都可以传入第二个参数，表示开始搜索的位置 1234var str = \"Hello World!\";str.startsWith(\"World\",6);//truestr.endsWith(\"Hello\",5);//truestr.includes(\"Hello\",6)//true 这里第二个参数n，endsWith是指前n个字符内的搜索，其余两个都是从第n个位置直到字符串结束的字符。 ###repeat() repeat方法返回一个新字符串，表示将原字符串重复n次 123456\"hello\".repeat(2)//hellohello'na'.repeat(2.9)//nana 参数是小数，被取整'na'.repeat(Infinity);//error'na'.repeat(-1);//error'na'.repeat(-0.9);//这里取0'na'.repeat('3')//nanana 参数字符串先转换为数字，再执行重复 ###padStart() padEnd() 字符串补全长度 padStart()头部补全 padEnd()尾部补全 123'x'.padStart(5,'ab')//ababx'x'.padEnd(5,'ab')//xabab'x'.padStart(5)//' x'//第二个参数不传，以空格代替 ###模版字符串 ES6中，引入了模版字符串，使用反引号(`)标识。 可以定义普通字符串，多行字符串，也可以在字符串中嵌入变量。 在模版字符串中嵌入变量，需要将变量名写在${}中。 12var name = \"Bob\" , time = \"today\";`Hello ${name},how are you ${time}?` 花括号内可以放入任意的javascript表达式，还可以调用函数 ###String.raw() 模版字符串的处理函数，返回一个反斜线都被转义的字符串。 1String.raw`Hi\\n${2+3}!`;//\"Hi\\\\n5!\"","link":"/2016/03/25/Ecmascript2015学习笔记/字符串的扩展/字符串的扩展/"},{"title":"ECMAScript2015学习笔记-数值的扩展","text":"##Number对象的扩展 ###Number.isFinite(),Number.isNaN() ES6在Number对象上提供了Number.isFinite()和Number.isNaN()两个方法，用来检查Infinite和NaN这两个特殊值 Number.isFinite()用来检测一个数值是否为非无穷 12345678Number.isFinite(15);//trueNumber.isFinite(0.8);//trueNumber.isFinite(NaN);//falseNumber.isFinite(Infinity);//falseNumber.isFinite(-Infinity);//falseNumber.isFinite('foo');//falseNumber.isFinite('15');//falseNumber.isFinite(true);//false Number.isNaN()用来检测一个值是否为NaN 1234567Number.isNaN(NaN);//trueNumber.isNaN(15);//falseNumber.isNaN('15');//falseNumber.isNaN(true);//falseNumber.isNaN(9/NaN);//trueNumber.isNaN('true'/0);//trueNumber.isNaN('true'/'true');//true 这两个方法与传统的全局方法isFinite(),isNaN的区别在于，传统方法先调用Number()将非数值转换为数值，再进行判断。而Number上的新方法只对数值有效，其余一律为false。 ###Number.parseInt().Number.parseFloat();在ES6中，将这两个常用的数值方法，从全局对象上移到了Number对象上，只是为了减少全局性的方法。 ###Number.isInteger()用来判断一个值是否为整数。整数和浮点数是同样的存储方法。 12345Number.isInteger(25)//trueNumber.isInteger(25.0)//trueNumber.isInteger(25.1)//falseNumber.isInteger(\"15\")//falseNumber.isInteger(true)//false ###Number.EPSTLIONES6新增了一个极小常量，Number.EPSTLION 123Number.EPSTLION//2.220446049250313e-16Number.EPSTLION.toFixed(20);//'0.00000000000000022204' 引入这样的一个常量，是为了解决JS的一个遗留问题，浮点数计算误差，如果误差小于Number.EPSTLION，那么，所得结果就是正确的。 ###安全整数和Number.isSafeInteger()整数的范围一般在-2^{53}到2^{53}之间(不含两个端点) ES6中引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER两个常量，用来表示整数范围的上下限。 Number.IsSafeInteger()用来判断一个整数是否在这个范围内 ##Math对象的扩展 ###Math.trunc()Math.trunc()用于除去一个数的小数部分，返回整数部分 12345678910111213Math.trunc(4.1);//4Math.trunc(4.9);//4Math.trunc(-4.1);//-4Math.trunc(-4.9);//-4Math.trunc(-0.1234);//-0Math.trunc('123.456');//123 先通过Number转换为数值//空值和无法截取整数的值，返回NaNMath.trunc(NaN);//NaNMath.trunc('f00');//NaNMath.trunc();//NaN ###Math.sign()Math.sign()用于判断一个数到底是正数，负数，还是零。 1234567Math.sign(-5);//-1Math.sign(5);//1Math.sign(0);//+0Math.sign(-0);//-0Math.sign(NaN);//NaNMath.sign('foo');//NaNMath.sign();//NaN ###Math.cbrt()Math.cbrt()用于计算一个数的立方根 1234Math.cbrt(-1);//-1Math.cbrt(0);//0Math.cbrt(1);//1Math.cbrt(2);//1.2599210498948734 ###Math.clz32()Math.clz32()返回一个数的32位无符号整数形式有多少个前导0 1234Math.clz32(0)//32Math.clz32(1)//31Math.clz32(1000)//22Math.clz32(0b01000000000000)//1 ###Math.imul()Math.imul()返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。 123Math.imul(2,4);//8Math.imul(-1,8);//-8Math.imul(-2,-2);//4 ###Math.fround()Math.fround()返回一个数的单精度浮点数形式。 12345Math.fround(0);//0Math.fround(1);//1Math.fround(1.337);//1.337000012397Math.fround(1.5);//1.5Math.fround(NaN);//NaN ###Math.hypot()Math.hypot()返回所有参数的平方和的平方根 1234Math.hypot(3,4);//5Math.hypot(3,4,5);//7.0710678118654755Math.hypot();//0Math.hypot('NaN');//NaN ###Math.expm1()Math.expm1()返回e^x-1，即Math.exp(x)-1; ###Math.log1p()Math.log1p()返回\\ln(1+x),Math.log(1+x).如果x小于-1，返回NaN。 ###Math.log10()Math.log10()返回以10为底的x的对数。如果x小于0，返回NaN。 ###Math.log2()Math.log10()返回以2为底的x的对数。如果x小于0，返回NaN。 ###三角函数 123456Math.sinh(x);//返回x的双曲正弦Math.cosh(x);//返回x的双曲余弦Math.tanh(x);//返回x的双曲正切Math.asinh(x);//返回x的反双曲正弦Math.acosh(x);//返回x的反双曲余弦Math.atanh(x);//返回x的反双曲正切 ###指数 ES7新增指数运算符(**) 122 ** 2;//42 ** 3;//8","link":"/2016/03/30/Ecmascript2015学习笔记/数值的扩展/数值的扩展/"},{"title":"ECMAScript2015学习笔记-正则的扩展","text":"###RegExp构造函数 ES6中，允许RegExp构造函数接受正则表达式作为参数，这时会返回一个原有正则表达式的拷贝。 1var regex = new RegExp(/xyz/i); 如果使用RegExp构造函数的第二个参数指定修饰符，则返回的正则表达式会忽略掉原有的正则表达式的修饰符，只使用新指定的修饰符。 1new RegExp(/abc/ig,'i').flags//\"i\" ###字符串正则 对于字符串对象，一共有四种方法可以使用正则表达式，全部调用RegExp的实例方法，这四种方法是：match(),replace(),search(),split() ###y修饰符 y修饰符又称粘连修饰符(sticky)，与g修饰符类似，全局匹配。 与g修饰符不同，y修饰符的匹配，总是从剩余的第一个位置开始，例如： 1234var s = \"aaa_aa_a\";var r = /a+_/y;r.exec(s);//['aaa_'];r.exec(s);//['aa_']; ###sticky属性 表示是否设置了y修饰符 12var r = /hello\\d/y;r.sticky//true ###flags属性 返回正则表达式的修饰符 12/abc/ig.source//\"abc\"返回正则表达式的正文/abc/ig.flag//\"gi\"//返回正则表达式的修饰符 ###RegExp.escape() 字符串转义为正则模式，未被标准化，不建议使用","link":"/2016/03/24/Ecmascript2015学习笔记/正则的扩展/正则的扩展/"},{"title":"ECMAScript2015学习笔记-Let和Const用法","text":"##Let ###作用域 let是ES6中新增的一种声明变量的方式，与var的用法类似，但是使用let声明的变量只在其所在的代码块内有效，例如： 1234567｛ let a = 10; var b = 20; ｝ console.log(a)// a is not defined console.log(b)// b:1 在for循环中，let就显得尤为实用 12345for(let i = 0;i&lt;10;i++){ consolog.log(i)//0123456789}console.log(i)//ReferenceError let声明的i只在其代码块内的作用域有效。 ###变量提升 let与var不同，不会出现变量提升这种现象，也就是说，通过let声明的变量，一定要先声明，再使用。例如： 1234console.log(a);//ReferenceErrorlet a = 2;typeof b;//ReferenceError 上面代码中，a由于在声明前就被使用，所以就抛出了一个错误，类似的，typeof在这里，也不可检测未被生命的变量。 ###暂时性死区 看下面这段代码： 123456var tmp = 123;if(true){ tmp = 'abc'; let tmp;} 代码中存在了一个全局变量tmp，在if条件语句的块级作用域内又使用let声明了一个局部变量tmp，此时，块级作用域内的tmp就会绑定整个区域，也就是说，在块级作用域的内部，tmp未被定义就被赋值，这时就会抛出错误。 在块级作用域内部，声明某个变量之前，这个变量都是不可用的，这在语法上成为暂时性死区 以下这些例子就很好的说明了暂时性死区的问题： 1234function bar(x=y,y=2){ return [x,y]}bar(); ###不允许重复声明 let不允许在相同作用域内重复声明同一个变量，例如 12345function(){ let a = 10; var a = 1; //报错} ###块级作用域在ES6中，每一个”{}”包裹的代码就是一个块级作用域，块级作用域可以进行任意的嵌套，块级作用域中的变量不可被外层访问到，但内层作用域可以定义外层作用域中的同名变量。 在严格模式下，函数只能在顶层作用域和函数内声明，其他情况（if代码块，循环代码块）下的声明都会报错。 ##Const const用来声明常量。声明之后，该常量的值不可改变。例如： 123const PI = 3.1415;console.log(PI);//3.1415PI = 3;//PI is read-only const声明的常量不可改变值，声明之时，就必须要赋值，否则会报错 与let一样，const声明的常量只在所在的块级作用域内有效 与let一样，const声明的常量也存在暂时性死区，只能在声明后使用 ###const声明指向 对于复合类型的变量,变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变。例如： 12345const foo = {}; //存储地址foo.prop = 123;//可变对象foo.prop//123foo = {}//error ##全局对象属性var,function声明的全局变量依旧是全局对象的属性。let,const,class声明的全局变量不属于全局对象的属性。","link":"/2016/03/23/Ecmascript2015学习笔记/Let和Const用法/Let和Const用法/"},{"title":"Nodejs入门-文件I/O-fs模块","text":"开发中我们经常会有文件I/O的需求，node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。 writeFilefs模块提供writeFile函数，可以异步的将数据写入一个文件,如果文件已经存在则会被替换。用法如下： 例：fs.writeFile(filename, data, callback) 123456var fs = require(\"fs\"); fs.writeFile('test.txt', 'Hello Node', function (err) { if (err) throw err; console.log('Saved successfully'); //文件被保存}); 数据参数可以是string或者是Buffer,编码格式参数可选，默认为”utf8”，回调函数只有一个参数err。 appendFilefs模块中还有appendFile函数，它可以将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件。使用方法如下： 例：fs.appendFile(文件名,数据,编码,回调函数(err)); 12345678var fs= require(\"fs\"); fs.appendFile('test.txt', 'data to append', function (err) { if (err) throw err; //数据被添加到文件的尾部 console.log('The \"data to append\" was appended to file!'); }); exists如何检查一个文件是否存在呢？我想exists函数可以帮助你，用法如下： 例：fs.exists(文件，回调函数(exists)); exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在。 12345var fs= require(\"fs\"); fs.exists('/etc/passwd', function (exists) { console.log(exists ? \"存在\" : \"不存在!\");}); rename修改文件名称是我们经常会遇见的事情，rename函数提供修改名称服务： 123456var fs= require(\"fs\"); fs.rename(旧文件，新文件，回调函数(err){ if (err) throw err; console.log('Successful modification,');}); 移动文件也是我们经常会遇见的，可是fs没有专门移动文件的函数，但是我们可以通过rename函数来达到移动文件的目的，示例如下。 123456var fs = require('fs'); fs.rename(oldPath,newPath,function (err) { if (err) throw err; console.log('renamed complete');}); readFile读取文件是最常用到的功能之一，使用fs模块读取文件语法如下： 例：fs.readFile(文件,编码,回调函数); 123456var fs = require('fs'); fs.readFile(文件名, function (err, data) { if (err) throw err; console.log(data);}); 回调函数里面的data,就是读取的文件内容。 unlink面对一堆垃圾的文件总是有想删除的冲动，我有强迫症？你才有呢。 好在有unlink函数，终于得救了，示例如下： 例：fs.unlink(文件,回调函数(err)); 123456var fs = require('fs'); fs.unlink(文件, function(err) { if (err) throw err; console.log('successfully deleted');}); mkdir除了针对文件的操作，目录的创建、删除也经常遇到的，下面我们来看看node.js中如何创建目录： 1fs.mkdir(路径，权限，回调函数(err)); 参数：路径：新创建的目录。权限：可选参数，只在linux下有效，表示目录的权限，默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作。回调函数：当发生错误时，错误信息会传递给回调函数的err参数。 rmdir删除目录也是必不可少的功能，rmdir函数可以删除指定的目录： 例：fs.rmdir(路径，回调函数(err)); 123456var fs = require('fs'); fs.rmdir(path, function(err) { if (err) throw err; console.log('ok');}); readdir如果要读取目录下所有的文件应该怎么办呢？readdir函数可以读取到指定目录下所有的文件，示例如下： 123var fs = require('fs'); fs.readdir(目录,回调函数(err,files)); 回调函数 (callback) 接受两个参数 (err, files) 其中 files 是一个存储目录中所包含的文件名称的数组，数组中不包括 ‘.’ 和 ‘..’。","link":"/2016/07/11/nodejs学习/文件I:O-fs模块/文件I O-fs模块/"},{"title":"ECMAScript2015学习笔记-变量的解构赋值","text":"##何为解构赋值 ES6中允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 ##模式匹配 等号两边的模式相同，左边的变量就会被赋予对应的值 一个最简单的例子： 1var [a,b,c] = [1,2,3] 这种写法成为“模式匹配”，按照位置的对应关系对变量赋值。 嵌套的数组也可以进行解构： 1var [foo,[[bar],baz]] = [1,[[2],3]]; 如果解构不成功，变量的值就等于undefined，例如： 12var [foo] = [];var [bar,foo] = [1]; ##不完全解构 等号左边的模式只匹配等号右边数组的一部分 例如： 12let [x,y] = [1,2,3];let [a,[b],d] = [1,[2,3],4]; 如果等号右边的不是数组（不可遍历的解构），就会报错 ##默认值 解构赋值允许指定默认值。例如： 1var [foo = true] = []; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 12let [x = 1,y = x] = [];//x=1,y=1let [x = y,y = 1] = [];//y没有提前声明，会报错。 ##对象的解构赋值 1var {bar,foo} = {foo:\"aaa\",bar:\"bbb\"}; **对象的属性没有次序，变量必须与属性同名，才能取到正确的值** 对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。 1var {foo:foo,bar:bar} = {foo:\"aaa\",bar:\"bbb\"}; 对于let和const而言，变量不能重新声明。 12let foo;let {foo} = {foo:1};//error 与数组一样，解构也可用于嵌套解构的对象 12345678910var obj = { p:[ \"Hello\", { y:\"World\" } ]}var {p:[x,{y}]} = obj; 对象解构也可以指定默认值 1var {x = 4} = {}; ###其他的解构赋值 12345678const [a,b,c,d,e] = 'hello'//字符串let {toString:s} = 123;//数值let {toString:s} = true//布尔function add([x,y]){ return x+y;}add([1,2])//3 函数","link":"/2016/03/23/Ecmascript2015学习笔记/变量的解构赋值/变量的解构赋值/"},{"title":"变量，作用域，内存—基本类型与引用类型","text":"当将一个值赋给一个变量时，解释器会确定这个值是基本类型还是引用类型，基本类型就是基础数据类型中的五种之一，如果是引用类型，当复制保存着对象的某个变量时,操作的是对象的引用。但在为对象添加属性时,操作的是实际 的对象。 动态属性对于引用类型的值，通过实例化对象的方式，将值赋予变量保存，可以对其添加属性和方法，或者删除属性和方法。 123var person = new Object(); person.name = \"Nicholas\"; alert(person.name); //\"Nicholas\" 只有引用类型的值可以对其属性和方法进行操作，基本类型的值就不可以。 复制变量值对于基本类型来说，如果从一个变量向另一个变量复制基本类型的值,会在变量对象上创建一个新值,然后把该值复制 到为新变量分配的位置上。 12var num1 = 5;var num2 = num1; 当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份放到 为新变量分配的空间中。不同的是,这个值的副本实际上是一个指针,而这个指针指向存储在堆中的一 个对象。复制操作结束后,两个变量实际上将引用同一个对象。 1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"Nicholas\";alert(obj2.name); //\"Nicholas\" 传递参数ECMAScript 中所有函数的参数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样。引用类型值传递，会把这个值的地址复制给一个局部变量 1234567function setName(obj) { obj.name = \"Nicholas\";}var person = new Object();setName(person);alert(person.name); //\"Nicholas\" 检测类型typeof123456789101112var s = \"Nicholas\";var b = true;var i = 22;var u;var n = null;var o = new Object();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof o); //object instanceofresult = variable instanceof constructor 123alert(person instanceof Object); // 变量 person 是 Object 吗? alert(colors instanceof Array); // 变量 colors 是 Array 吗? alert(patterninstanceofRegExp); //变量pattern是RegExp吗?","link":"/2016/07/11/我的JavaScript学习笔记/变量，作用域，内存—基本类型与引用类型/变量，作用域，内存—基本类型与引用类型/"},{"title":"在服务器上搭建MongoDB，完成远程连接","text":"最近在使用nodejs做开发，坑真多啊，就不吐槽了。在应用开发过程中，总需要本地搭建一个数据库，每次启动服务的时候就要保持不关闭命令行，我嫌烦，就准备在远程服务器上搭建一个，本地直接连接远程的。 ##Mongodb的安装安装教程我在这里就不多说了，网上有一大堆教程，最好的还是去查看官方的文档，我们需要将Mongodb安装在服务器环境中。这里我找了几个教程：windows环境下的安装：点击链接mac环境下的安装：点击链接 ##开启远程服务 ###添加一个管理员账户安装好Mongodb之后，首先在bin目录下启动mongodb服务，再新建命令窗口，键入命令 1mongo 再输入命令 1use admin 接着我们创建一个用户：Mongodb在3.0版本时候去除了addUser这个方法，我们需要这样来创建用户 12345678910db.createUser( { user: \"&lt;username&gt;\", pwd: \"&lt;password&gt;\", roles: [ \"readWrite\", \"dbAdmin\" ] })//&lt;username&gt; 用户名//&lt;password&gt; 密码 ###配置mongodb.conf 12#bind_ip = 127.0.0.1 //注释此行 auth = true //将此行前的注释去掉 ###重启mongodb ###防火墙开放27017端口具体开放方法我在这里就不过多描述了。 ###测试连接我们回到本地环境中，新打开一个终端命令 1mongo 你的服务器ip地址:27017/admin -u frontdev -p frontdev 不出意外的话，我们的数据库已经连接成功了。 ##如何使用这里我以nodejs为例，演示如何在express中使用远程连接。首先我们建立settings.js文件 123456module.exports = { url:'mongodb://&lt;username&gt;:&lt;password&gt;@你的服务器ip地址/admin'};//&lt;username&gt;刚才你设置的用户名//&lt;password&gt;刚才你设置的密码 接下来，在模块中引入模块： 12var mongodb = require('mongodb').MongoClient, settings = require('../settings'); 打开数据库进行查询 12345mongodb.connect(settings.url, function (err, db) { if (err) { return callback(err); } }); 至此，我们就完成了mongoDB远程连接及使用","link":"/2016/04/11/MogoDB/在服务器上搭建MongoDB，完成远程连接/在服务器上搭建MongoDB，完成远程连接/"},{"title":"基本概念—函数","text":"函数基本function functionName(arg0, arg1,...,argN) { statements } 一个函数体包括，函数体的声明，函数体名称，函数体接收的参数名，以及执行语句。例如： 123function sayHi(name, message) { alert(\"Hello \" + name + \",\" + message); } 其中，function是函数体声明，sayHi是函数体的名称，接收了name，message参数，花括号内部是该函数的执行语句，调用浏览器windows对象上的alert方法，将传递进去的name，message具体值通过弹窗形式展现出来。函数在定义时不必指定返回值，但函数可以通过return来实现返回值。位于 return 语句之后的任何代码都永远不会执行。 在严格模式下： 不能把函数命名为 eval 或 arguments; 不能把参数命名为 eval 或 arguments; 不能出现两个命名参数同名的情况。 参数的理解 ECMAScript函数不介意传递进 来多少个参数,也不在乎传进来参数是什么数据类型。 arguments 对象只是与数组类似(它并不是 Array 的实例) 通过arguments.length可以获取到参数的个数。 与其他语言不同，函数的参数传递可以不用指定参数名称，也可以不进行传递。 ECMAScript 中的所有参数传递的都是值,不可能通过引用传递参数。 重载ECMAScript中的函数不像其他语言具有函数签名的特性，所以，ECMAScript的函数就不能重载，只能通过arguments的判断来模拟重载","link":"/2016/07/11/我的JavaScript学习笔记/基本概念—函数/基本概念—函数/"},{"title":"基本概念—操作符","text":"一元操作符递增递减操作符 前置递增操作符 ++ var age = 29;++age; 前置递减操作符 -- var age = 29;--age; 后置递增操作符 ++ var age = 29;age++; 后置递减操作符 -- var age = 29;age--; 前置操作符和后置操作符的区别在于，前置操作符在其求值之前就运行，而后置操作符在其求值之后运行。 加减操作符 加 + var a = 2+1; 减 - var b = 2-1; 位操作符按位非(NOT)执行按位非的结果就是返回数值的反码。 123var num1 = 25;var num2 = -num1 - 1;alert(num2); // \"-26\" 按位与(AND)按位与操作只在两个数值的对应位都是 1 时才返回 1,任何一位是 0,结果都是 0。 12var result = 25 &amp; 3;alert(result); //1 按位或(OR)按位或操作在有一个位是 1 的情况下就返回 1,而只有在两个位都是 0 的情况下才返回 0。 12var result = 25 | 3;alert(result); //27 按位异或(XOR)两个数值对应位上只有一个 1 时才返回 1,如果对 应的两位都是 1 或都是 0,则返回 0。 12var result = 25 ^ 3;alert(result); //26 左移(&lt;&lt;)将数值的所有位向左移动指定的位数。 12var oldValue = 2; // 等于二进制的10var newValue = oldValue &lt;&lt; 5; // 等于二进制的1000000,十进制的64 右移(&gt;&gt;)将数值的所有位向右移动指定的位数。 12var oldValue = 64; // 等于二进制的1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的10 ,即十进制的2 无符号右移(&gt;&gt;&gt;)将数值的所有 32 位都向右移动。 12var oldValue = 64; // 等于二进制的1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的10 ,即十进制的2 布尔操作符逻辑非(!)可以应用于 ECMAScript 中的任何值。返回一个布尔值。先将操作数转换成为一个布尔值，再对这个布尔值进行取反。 123456alert(!false);// truealert(!\"blue\");// falsealert(!0);// truealert(!NaN);// truealert(!\"\");// truealert(!12345);// false 逻辑与(&amp;&amp;)逻辑与操作符由两个和号(&amp;&amp;)表示,有两个操作数 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 123456alert({}&amp;&amp;1);// 1alert(1&amp;&amp;{});// Object {}alert({}&amp;&amp;{'name':1});// Object {name: 1}alert({}&amp;&amp;null);// nullalert({}&amp;&amp;NaN);// NaNalert({}&amp;&amp;undefined);// undefined 如果第一个操作数能够决定结果,那么就不会再对第二个操作数求值。 逻辑或(||)逻辑或操作符由两个竖线符号(||)表示,有两个操作数 第一个操作数 第二个操作数 结果 True true true True false true false true true false false false 123456alert({}||1);// {}alert(false||{});// Object {}alert({}||{'name':1});// Object {}alert(null||null);// nullalert(NaN||NaN);// NaNalert(undefined||undefined);// undefined 如果第一个操作数的求值结果为 true,就不会对第二个操作数求值了。 乘性操作符乘法(*)乘法操作符由一个星号(*)表示,用于计算两个数值的乘积。 123456alert(5*6); //30alert(5*NaN); //NaNalert(Infinity*0); //NaNalert(Infinity*10); //Infinityalert(Infinity*Infinity); //Infinityalert(1*'10')=&gt;alert(1*Number('10'))=&gt;alert(1*10) //10 除法(/)除法操作符由一个斜线符号(/)表示,执行第二个操作数除第一个操作数的计算 1234567alert(4/2); //2alert(4/NaN); //NaNalert(Infinity/Infinity) //NaNalert(0/0) //NaNalert(4/0) //Infinityalert(Infinity/4) //Infinityalert(4/'2')=&gt;alert(4/Number('2'))=&gt;alert(4/2) //2 求模(%)求模(余数)操作符由一个百分号(%)表示 1234567alert(26%5); //1alert(Infinity%100);//NaNalert(100%0); //NaNalert(Infinity%Infinity); //NaNalert(100%Infinity); //100alert(0%100); //0alert(0%'100')=&gt;alert(0/Number('100'))=&gt;alert(0/100) //0 加性操作符加法(+)加法操作符(+) 123456789101112alert(1+1);//2alert(1+NaN);//NaNalert(Infinity+Infinity);//Infinityalert(-Infinity+-Infinity);//-Infinityalert(Infinity+-Infinity);//NaNalert(0+0);//0alert(-0+-0);//-0alert(0+-0);//0alert('1'+'2') //'12'alert('1'+2) //'12'alert('1'+2) 如果有一个操作数是对象、数值或布尔值,则调用它们的 valueOf()方法取得相应的字符串值,然后再应用前面关于字符串的规则。对于 undefined 和 null,则分别调用 String()函数并取得字符 串”undefined”和”null”。 减法(-)减法操作符(-) 123456789101112alert(1-1);//2alert(1-NaN);//NaNalert(Infinity-Infinity);//NaNalert(-Infinity--Infinity);//-NaNalert(Infinity--Infinity);//Infinityalert(0-0);//0alert(0--0);//-0alert(-0--0);//0alert('1'+'2') //'12'alert('1'+2) //'12'alert('1'+2) 关系操作符小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)这几个关系操作符用于对两个值进行比较 字符串比较的是字符编码 在比较 数值和字符串时,字符串都会被转换成数值,然后再以数值方式与另一个数值比较。 相等操作符相等和不相等ECMAScript 中的相等操作符由两个等于号(==)表示,如果两个操作数相等,则返回 true。 而不相等操作符由叹号后跟等于号(!=)表示,如果两个操作数不相等,则返回 true。 如果一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，true转换为1. 如果一个操作数是字符串,另一个操作数是数值,在比较相等性之前先将字符串转换为数值; 如果一个操作数是对象,另一个操作数不是,则调用对象的 valueOf()方法,用得到的基本类型值按照前面的规则进行比较; 表达式 值 null == undefined true “NaN” == NaN false 5 == NaN false NaN == NaN false NaN != NaN true false == 0 true true == 1 true true == 2 false undefined == 0 false null == 0 false “5”==5 true 全等和不全等全等操作符由 3 个等于号(===)表示,它只在两个操作数未经转换就相等的情况下返回 true 不全等操作符由一个叹号后跟两个等于号(!==)表示,它在两个操作数未经转换就不相等的情况 下返回 true 12var result1 = (\"55\" == 55); //true,因为转换后相等var result2 = (\"55\" === 55); //false,因为不同的数据类型不相等 相对于相等操作符，全等操作符更加优秀，加入了类型比较。 条件操作符variable = boolean_expression ? true_value : false_value; 赋值操作符赋值操作符使用=号表示，作用就是把右侧的值赋给左侧的变量。如果在等于号(=)前面再添加乘性操作符、加性操作符或位操作符,就可以完成复合赋值操作。目的是为了简化操作。 逗号操作符使用逗号操作符可以在一条语句中执行多个操作 12var num1=1, num2=2, num3=3;var num = (5, 1, 4, 8, 0); // num的值为0","link":"/2016/07/11/我的JavaScript学习笔记/基本概念—操作符/基本概念—操作符/"},{"title":"基本概念—数据类型","text":"Undefined 使用 var 声明变量但未对其加以初始化时的值 Null 表示一个空对象指针 undefined 值是派生自 null 值的 1alert(null == undefined); //true 在保存一个空对象的时候，使用null，而不是使用undefined，这样可以清楚地表明该变量存储的是一个空对象指针。 Boolean 两个值 true和false 要将一个值转换为其对应的 Boolean 值,可以调用转型函数 Boolean() 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”(空字符串) Number 任何非零数字值(包括无穷大) 0和NaN Object 任何对象 null Undefined n/a undefined Number 整数 var num = 1; 八进制 var num = 070; 十六进制 var num = 0xA; 浮点数 var num = 0.1; 科学计数法 var floatNum = 3.125e7; 访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以 得到负和正 Infinity 的值。 NaN 表示一个本来要返回数值的操作数未返回数值的情况 isNaN() 检测参数是否“不是数值” 数值转换Number() parseInt() parseFloat() 转换规则 如果是 Boolean 值,true 和 false 将分别被转换为 1 和 0。 如果是数字值,只是简单的传入和返回。 如果是 null 值,返回 0。 如果是 undefined,返回 NaN。 字符串 只包含数字，转换为十进制 只包含浮点数，转换为浮点数 包含十六进制，转换为十进制整数型 为空(不包含任何字符)，转换为0 包含除上述格式之外的字符 转换为 NaN 如果是对象,则调用对象的 valueOf()方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN,则调用对象的 toString()方法,然后再次依照前面的规则转换返回的字符串值。 String 由单引号’’或者双引号””表示，两种写法没有什么分别 字符字面量 字面量 含义 \\n 换行 \\t 制表 \\b 退格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\’ 单引号(‘),在用单引号表示的字符串中使用。例如:’He said, \\’hey.\\’’ \\” 双引号(“),在用双引号表示的字符串中使用。例如:”He said, \\”hey.\\”” \\xnn 以十六进制代码nn表示的一个字符(其中n为0~F)。例如,\\x41表示”A” \\unnnn 以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如,\\u03a3表示希腊字符Σ 字符串特点 一旦创建，就不可改变。 字符串转换 一般调用toString()方法。null 和 undefined 值没有这个方法 数值在调用toString()方法时，可以传递参数，输出二进制、八进制、十六进制,乃至其他任意有效进制格 式表示的字符串值 Object使用new操作符来创建新对象Object 的每个实例都具有下列属性和方法。 constructor:保存着用于创建当前对象的函数。 hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中,作为参数的属性名(propertyName)必须以字符串形式指定 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句 toLocaleString():返回对象的字符串表示,该字符串与执行环境的地区对应。 toString():返回对象的字符串表示。 valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。","link":"/2016/07/11/我的JavaScript学习笔记/基本概念—数据类型/基本概念—数据类型/"},{"title":"基本概念—语句","text":"if语句if (condition) statement1 else statement2 12345if (i &gt; 25) alert(\"Greater than 25.\");else { alert(\"Less than or equal to 25.\");} do-while语句do { statement } while (expression); 123var i = 0;} while (i &lt; 10);alert(i); while语句while(expression) statement 1234var i = 0;while(i&lt;10){ i+=2;} for语句for (initialization; expression; post-loop-expression) statement 1234var count = 10;for (var i = 0; i &lt; count; i++){ alert(i); } for-in语句for (property in expression) statement 123for (var propName in window) { document.write(propName);} label语句label: statement 123start: for (var i=0; i &lt; count; i++) { alert(i);} break和continue语句break 语句会立即退出循环, 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环,但退出循环后会从循环的顶 部继续执行。 12345678910var num = 0;for (var i=1; i &lt; 10; i++) { if (i % 5 == 0) { break; } num++; }alert(num); //4 with语句with (expression) statement; switch语句switch 语句在比较值时使用的是全等操作符,因此不会发生类型转换(例如, 字符串”10”不等于数值 10)。 1234567891011switch (expression) { case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement}","link":"/2016/07/11/我的JavaScript学习笔记/基本概念—语句/基本概念—语句/"},{"title":"基本概念—语法和关键字","text":"区分大小写 ECMAScript 中的一切(变量、函数名和操作符)都区分大小写 标识符 第一个字符必须是一个字母、下划线(_)或一个美元符号($); 其他字符可以是字母、下划线、美元符号或数字。 标识符采用驼峰大小写格式，例如：firstSecond **myCar** doSomethingImportant 不能把关键字、保留字、true、false 和 null 用作标识符 注释 单行注释 //..... 多行注释 /* 这是一个多行 * (块级)注释 */ 严格模式 在严格模式下,ECMAScript 3 中的一些不确定的行为将得到处理,而且对某些不安全 的操作也会抛出错误。 顶部添加如下代码：&quot;use strict&quot;; 在函数内部的开头也可以加入严格模式 1234function doSomething(){ \"use strict\"; //函数体 } 语句 以英文半角分号结尾 ; 例如：var a = 2+1; 不加分号的话，解释器会自行添加结尾符号，推荐做法是加上分号。 关键字breakcasecatchcontinuedebugger*defaultdeletedoinstanceofelsenewfinallyreturnforswitchfunctionthisifthrowintrytypeofvarvoidwhilewith 变量 变量是松散型的，可以保存任何类型的数据 使用var操作符定义变量，例如：var message = null; 用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。 不适用var操作符定义变量，就会使该变量变为全局变量，污染全局的做法慎用 在严格模式下,不能定义名为 eval 或 arguments 的变量,否则会导致语法错误。 数据类型 基本类型：Undefined、Null、Boolean、Number 和 String 复杂数据类型：Object 检测数据类型 typeof操作符 “undefined”——如果这个值未定义; “boolean”——如果这个值是布尔值; “string”——如果这个值是字符串; “number”——如果这个值是数值; “object”——如果这个值是对象或 null; “function”——如果这个值是函数。","link":"/2016/07/11/我的JavaScript学习笔记/基本概念—语法和关键字/基本概念—语法和关键字/"},{"title":"引用类型","text":"Object类型创建方式 使用 new 操作符后跟 Object 构造函数 123var person = new Object();person.name = \"Nicholas\";person.age = 29; 使用对象字面量表示法 1234var person = { name : \"Nicholas\", age : 29}; 访问方式属性的访问方式有两种 使用.方式访问，例如 1console.log(person.name); 使用方括号方式访问，例如 1console.log(person[\"name\"]); 如果属性名中包含会导致语法错误的字符,或者属性名使用的是关键字或保留字,也可以使用方括 号表示法。 Array类型创建方式12345var colors = new Array();var colors = new Array(20); //长度为20的数组var colors = new Array(\"red\", \"blue\", \"green\");var colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组var names = [];//创建一个空数组 读取在读取和设置数组的值时,要使用方括号并提供相应值的基于 0 的数字索引 123var colors = [\"red\", \"blue\", \"green\"]; // 定义一个字符串数组alert(colors[0]);//显示第一项alert(colors.length);//返回数组的长度 检测ES5中定义了Array.isArray()方法，用来检测是否为数组，返回的是一个Boolean类型的值 方法push()接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改过后数组的强度。 1var colors = new Array(); var count = colors.push(\"red\", \"green\"); alert(count); //2 pop()从数组末尾移除最后一项，减少数组的length值，并返回移除项 1var item = colors.pop(); alert(item); //\"black\" alert(colors.length); //2 shift()移除数组中第一个项并返回该项，同时将数组长度减1 1var colors = new Array(); var count = colors.push(\"red\", \"green\"); alert(count); //2 count = colors.push(\"black\"); alert(count); //3 var item = colors.shift(); alert(item); //\"red\" alert(colors.length); //2 unshift()在数组前端添加任意个项，并返回新数组的长度 reverse()将数组的顺序反转 1var values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); //5,4,3,2,1 sort()按照升序排列数组 123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5","link":"/2016/11/15/我的JavaScript学习笔记/引用类型/引用类型/"},{"title":"变量，作用域，内存—执行环境与作用域","text":"什么是执行环境定义执行环境定义了变量或函数有权访问的其他数据,决定了它们各自的行为。每个执行环境都有一个变量对象，在这个环境中定义的变量和函数都会被保存在这个对象之中。 全局执行环境是在最外部的一个执行环境，全局执行环境没有统一的规定，要根据语言的宿主环境来看，在浏览器中，全局执行环境就指的是window对象。所有全局变量，全局函数都是通过window对象创建的。某个执行环境在执行完毕之后，里面的变量和函数会被销毁，依赖于浏览器中的全局执行环境里的变量和函数，要在浏览器程序退出或者标签页关闭之后才会被销毁。 作用域链(scope chain)保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端,始终都是当前执行的代码所 在环境的变量对象。 活动对象在最开始时只包含一个变量,即 arguments 对象(这个对象在全局环境中是不存在的)。 全局执行环境的变量对象始终都是作用域链中的最后一个对象 12345678910111213var color = \"blue\"; function changeColor(){ var anotherColor = \"red\"; function swapColors(){ var tempColor = anotherColor; anotherColor = color; color = tempColor;// 这里可以访问color、anotherColor和tempColor }// 这里可以访问color和anotherColor,但不能访问tempColor swapColors(); }// 这里只能访问color changeColor(); 延长作用域链 try-catch 语句的 catch 块; with 语句。 没有块级作用域JavaScript不像其他语言一样，在花括号内就会形成一个作用域，像if条件语句，for循环这种执行语句，作用域就会指向全局， 声明变量使用 var 声明的变量会自动被添加到最接近的环境中。 查询标识符搜索过程从作用域链的前端开始,向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到 了该标识符,搜索过程停止,变量就绪。如果在局部环境中没有找到该变量名,则继续沿作用域链向上 搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符,则意味 着该变量尚未声明。","link":"/2016/07/12/我的JavaScript学习笔记/变量，作用域，内存—执行环境与作用域/变量，作用域，内存—执行环境与作用域/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"PostCss","slug":"PostCss","link":"/tags/PostCss/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"dos","slug":"dos","link":"/tags/dos/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"IE","slug":"IE","link":"/tags/IE/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"angularjs","slug":"angularjs","link":"/tags/angularjs/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"pm2","slug":"pm2","link":"/tags/pm2/"},{"name":"2015","slug":"2015","link":"/tags/2015/"},{"name":"自动化，打包工具","slug":"自动化，打包工具","link":"/tags/自动化，打包工具/"},{"name":"自动化","slug":"自动化","link":"/tags/自动化/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"小程序","slug":"小程序","link":"/tags/小程序/"},{"name":"Mobile","slug":"Mobile","link":"/tags/Mobile/"},{"name":"感悟","slug":"感悟","link":"/tags/感悟/"},{"name":"点滴","slug":"点滴","link":"/tags/点滴/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"OC","slug":"OC","link":"/tags/OC/"},{"name":"IOS","slug":"IOS","link":"/tags/IOS/"},{"name":"软件使用","slug":"软件使用","link":"/tags/软件使用/"},{"name":"EC2","slug":"EC2","link":"/tags/EC2/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Quiver","slug":"Quiver","link":"/tags/Quiver/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"我的JavaScript学习笔记","slug":"我的JavaScript学习笔记","link":"/tags/我的JavaScript学习笔记/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"}],"categories":[{"name":"技术分享","slug":"技术分享","link":"/categories/技术分享/"},{"name":"前端杂谈","slug":"前端杂谈","link":"/categories/前端杂谈/"},{"name":"git使用技巧","slug":"git使用技巧","link":"/categories/git使用技巧/"},{"name":"前端技术","slug":"前端技术","link":"/categories/前端技术/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"wordpress","slug":"wordpress","link":"/categories/wordpress/"},{"name":"个人感悟","slug":"个人感悟","link":"/categories/个人感悟/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"IOS开发","slug":"IOS开发","link":"/categories/IOS开发/"},{"name":"软件使用","slug":"软件使用","link":"/categories/软件使用/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"Jquery","slug":"Jquery","link":"/categories/Jquery/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"}]}